package com.epoch.synthesis;

import chemaxon.marvin.io.MolExportException;
import chemaxon.sss.search.SearchException;
import chemaxon.struc.MDocument;
import chemaxon.struc.Molecule;
import chemaxon.struc.graphics.MRectangle;
import com.epoch.chem.ChemUtils;
import com.epoch.chem.MolCompare;
import com.epoch.chem.MolCompareException;
import com.epoch.chem.MolString;
import com.epoch.chem.Normalize;
import com.epoch.chem.StereoFunctions;
import com.epoch.evals.impl.chemEvals.synthEvals.SynthOneRxn;
import com.epoch.evals.impl.chemEvals.synthEvals.SynthSelective;
import com.epoch.substns.SubstnUtils;
import com.epoch.synthesis.synthConstants.SynthConstants;
import com.epoch.utils.MathUtils;
import com.epoch.utils.Utils;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

/** Contains data and references to items inside a rectangle (box, stage). */
public class SynthStage implements SynthConstants {

	private void debugPrint(Object... msg) {
		// Utils.printToLog(msg);
	}

	private void debugPrintMRV(Object... msg) {
		// Utils.printToLog(msg, MRV);
	}

	//----------------------------------------------------------------------
	//							members
	//----------------------------------------------------------------------
	/** The box containing this stage. */
	private transient MRectangle box = null;
	/** The index of the box containing this stage in the MDocument. */
	private transient int boxIndex = NOT_FOUND;
	/** List of molecules in this stage of the synthesis. */
	private transient final List<Molecule> molecules = new ArrayList<Molecule>();
	/** List of molecules in this stage of the synthesis, normalized.
	 * Populated on the fly only if needed. */
	private transient Molecule[] normalizedMols = null;
	/** Enumerated stereoisomers of the normalized molecules in this stage of
	 * the synthesis.  Populated on the fly only if needed. */
	private final List<Molecule> enumStereos = new ArrayList<Molecule>();
	/** List of arrows pointing from immediately previous stages in the
	 * synthesis to this one. */
	private transient final List<SynthArrow> arrowsFromPrev = new ArrayList<SynthArrow>();
	/** List of stages in the synthesis immediately preceding this one. */
	private transient final List<SynthStage> prevStages = new ArrayList<SynthStage>();
	/** The arrow pointing from this stage to the next stage in the
	 * synthesis. */
	private SynthArrow arrowToNext = null;
	/** The next stage in the synthesis. */
	private SynthStage nextStage = null;
	/** ID number of reaction conditions selected for this stage. */
	private int rxnCondition = NOT_FOUND;
	/** Whether the reaction chosen for this stage is asymmetric. */
	private transient boolean rxnIsAsymmetric = false;
	/** MDocument of this stage containing all graphical objects. */
	// private MDocument stageMDoc = null; // unused 5/2011 Raphael
	/** MRV representation of this stage. */
	// private String stageXML = null; // unused 5/2011 Raphael
	/** The synthesis of which this stage is a member. */
	private transient Synthesis parentSynth = null;
	
	/** The products calculated from this stage's molecules and reaction
	 * conditions.  Populated when Synthesis.validRxnContents() needs the values. */
	private transient Molecule[] calculatedProds = null;
	/** The kind of error (or lack thereof) generated by this stage's molecules
	 * and reaction conditions. */
	private transient int rxnStatus = UNCHECKED;

	/** List of molecules that are NOT produced by reactions. Populated after
	 * calculatedProds has been. */
	private final List<Molecule> starters = new ArrayList<Molecule>();
	/** List of molecules that ARE produced by reactions. Populated after
	 * calculatedProds has been. */
	private final List<Molecule> notStarters = new ArrayList<Molecule>();
	/** Whether starters has been populated. */
	private boolean startersDetermined = false;

	//----------------------------------------------------------------------
	//							constructors
	//----------------------------------------------------------------------
	/** Constructor. */
	public SynthStage() {
		// intentionally empty
	}
	
	/** Constructor.
	 * @param	newBox	the box containing this stage's molecules and
	 * reaction conditions
	 * @param	newObjectIndex	the index of the box (in the MRV MDocument)
	 */
	public SynthStage(MRectangle newBox, int newObjectIndex) {
		box = newBox;
		boxIndex = newObjectIndex;
	} // SynthStage(MRectangle, int)

	//----------------------------------------------------------------------
	//							short add/set methods
	//----------------------------------------------------------------------
	/** Add a molecule to this stage.
	 * @param	newMol	the molecule to add
	 */
	public void addMolecule(Molecule newMol)		{ molecules.add(newMol); }
	/** Add the arrow to the list of arrows pointing from immediately previous
	 * stages in the synthesis to this one.
	 * @param	arrow	the arrow to add
	 */
	public void addArrowFromPrev(SynthArrow arrow) 	{ arrowsFromPrev.add(arrow); }
	/** Add the stage to the list of stages immediately previous to this one.
	 * @param	stage	the stage to add
	 */
	public void addPrevStage(SynthStage stage)		{ prevStages.add(stage); }
	/** Set the arrow pointing from this stage to the next stage in the
	 * synthesis.
	 * @param	arrow	the reaction arrow to set
	 */
	public void setArrowToNext(SynthArrow arrow)	{ arrowToNext = arrow; }
	/** Set the stage immediately following this one.
	 * @param	stage	the next stage
	 * @return	false if the next stage has already been set
	 */
	public boolean setNextStage(SynthStage stage) {
		if (nextStage != null) return false;
		nextStage = stage;
		return true;
	}
	/** Set whether it has been determined which compounds in this stage are
	 * produced by reactions, and which are not.
	 * @param	detd	whether compounds not produced by reactions have been
	 * identified
	 */
	public void setStartersDetermined(boolean detd) { startersDetermined = detd; }
	/** Set which compounds in this stage are NOT produced by reactions in
	 * previous stages.  Add each member of the list individually so it can be
	 * cloned.
	 * @param	startersList	list of compounds in this stage not produced by
	 * reactions
	 */
	public void setStarters(List<Molecule> startersList) {
		for (final Molecule starter : startersList)
			starters.add(starter.clone());
	}
	/** Set which compounds in this stage ARE produced by reactions in previous
	 * stages.  Add each member of the list individually so it can be cloned.
	 * @param	notStartersList	list of compounds in this stage produced by
	 * reactions
	 */
	public void setNotStarters(List<Molecule> notStartersList) {
		for (final Molecule notStarter : notStartersList)
			notStarters.add(notStarter.clone());
	}
	/** Set the parent synthesis of this stage. 
	 * @param	syn	the parent synthesis
	 */
	public void setParentSynth(Synthesis syn)		{ parentSynth = syn; }
	
	//--------------------------------------------------------------------------
	//							short get methods
	//--------------------------------------------------------------------------
	/** Get the rectangle enclosing the molecules and reaction conditions of
	 * this stage.
	 * @return	this stage's rectangle
	 */
	public MRectangle	getBox()					{ return box; }
	/** Get the 0-based index in the response's MDocument of the box enclosing
	 * this stage.
	 * @return	the 0-based index of this stage's box
	 */
	public int 			getBoxIndex()				{ return boxIndex; }
	/** Get the number of molecules in this stage.
	 * @return	the number of molecules in this stage
	 */
	public int 			getNumMolecules()			{ return molecules.size(); }	
	/** Get original list of originals of all molecules in this stage.
	 * @return	list of molecules (NOT cloned)
	 */
	List<Molecule> getOrigMoleculeList() 			{ return molecules; }
	/** Get array of originals of all molecules in this stage.
	 * @return	array of molecules (NOT cloned)
	 */
	public Molecule[] getMoleculeArray() {
		return Utils.molListToArray(molecules);
	}
	/** Get copies of all molecules in this stage.
	 * @return	list of cloned molecules
	 */
	public List<Molecule> getMoleculeList() {
		final List<Molecule> list = new ArrayList<Molecule>();
		for (final Molecule mol : molecules)
			list.add(mol.clone());
		return list;
	}
	/** Get a molecule from this stage.
	 * @param	index	0-based index of the molecule
	 * @return	the molecule
	 */
	public Molecule getMolecule(int index) {
		return molecules.get(index).clone();
	}
	/** Get whether there is a stage preceding this one.
	 * @return	true if there is a stage preceding this one
	 */
	public boolean hasPrevStage() 					{ return !prevStages.isEmpty(); }
	/** Get all stages immediately preceding this one.
	 * @return	list of stages immediately preceding this one
	 */
	public List<SynthStage> getAllPrevStages() 		{ return prevStages; }
	/** Get a stage immediately preceding this one.
	 * @param	i	0-based index of the stage
	 * @return	a stage immediately preceding this one
	 */
	public SynthStage 	getPrevStage(int i)			{ return prevStages.get(i); }
	/** Get the arrow pointing to this stage from one immediately preceding
	 * @param	i	0-based index of the stage (in the list of previous stages)
	 * whose arrow to get
	 * @return	arrow pointing to this stage from one immediately preceding
	 */
	public SynthArrow 	getArrowFromPrev(int i)		{ return arrowsFromPrev.get(i); }
	/** Get whether there is a stage following this one.
	 * @return	true if there is a stage following this one
	 */
	public boolean		hasNextStage()				{ return nextStage != null; }
	/** Get the stage immediately following this one.
	 * @return	the stage immediately following this one
	 */
	public SynthStage 	getNextStage()				{ return nextStage; }
	/** Get whether this stage is the target stage.
	 * @return	true if this stage is the target stage
	 */
	public boolean		isTargetStage()				{ return !hasNextStage(); }
	/** Get the arrow pointing from this stage to the next stage in the
	 * synthesis.
	 * @return	the arrow to the next stage; null if this stage is the last one
	 */
	public SynthArrow 	getArrowToNext()			{ return arrowToNext; }
	/** Get whether it has been determined which compounds in this stage are
	 * produced by reactions, and which are not.
	 * @return	true if it has been determined which compounds in this stage
	 * are not produced by reactions
	 */
	public boolean		areStartersDetermined()		{ return startersDetermined; }
	/** Get copies of all compounds in this stage NOT produced by reactions
	 * in previous stages.
	 * @return	list of compounds in this stage NOT produced by reactions in
	 * previous stages
	 */
	public List<Molecule> getStarters() {
		final List<Molecule> list = new ArrayList<Molecule>();
		for (final Molecule starter : starters)
			list.add(starter.clone());
		return list;
	}
	/** Get copies of all compounds in this stage that ARE produced by reactions
	 * in previous stages.
	 * @return	list of compounds in this stage that ARE produced by reactions in
	 * previous stages
	 */
	public List<Molecule> getNotStarters() {
		final List<Molecule> list = new ArrayList<Molecule>();
		for (final Molecule notStarter : notStarters)
			list.add(notStarter.clone());
		return list;
	}
	/** Get the ID number of the reaction conditions that will act on the
	 * compound or compounds in this stage.
	 * @return	reaction conditions' ID number (NOT_FOUND if none)
	 */
	public int 			getRxnCondition()			{ return rxnCondition; }
	/** Get whether the reaction chosen for this stage is asymmetric.
	 * @return	true if the reaction chosen for this stage is asymmetric.
	 */
	public boolean		isRxnAsymmetric()		{ return rxnIsAsymmetric; }
	/** Get the products calculated from this stage's molecules and reaction
	 * conditions.
	 * @return	an array of molecules that are the calculated products of this
	 * stage
	 */
	public Molecule[]	getRxnProducts()			{ return calculatedProds; }
	/** Gets the kind of error (or lack thereof) generated by this stage's molecules
	 * and reaction conditions.
	 * @return	number representing the kind of error or lack thereof
	 */
	public int			getRxnStatus() 				{ return rxnStatus; }

	//----------------------------------------------------------------------
	//							setRxnCondition
	//----------------------------------------------------------------------	
	/** Set the ID number of the reaction conditions that will act on the
	 * compound or compounds in this stage.
	 * @param	number	reaction conditions' ID number
	 */
	public void setRxnCondition(int number)			{ rxnCondition = number; }

	/** Sets the reaction condition ID of a stage.  Called by SynthParser when
	 * MarvinJS is being used.
	 * @param	rxnPosn	the position of the reaction condition in the array of
	 * conditions chosen by the user
	 * @param	conditions	array of Strings representing reaction condition IDs
	 * @param	conditionsRange	the range of condition numbers chosen by the
	 * user
	 * @throws	SynthError	if a box has more than one number
	 */
	void setRxnCondition(int rxnPosn, String[] conditions, 
			int[] conditionsRange) throws SynthError {
		final String SELF = "SynthStage.setRxnCondition: ";
		if (getRxnCondition() != NOT_FOUND) {
			debugPrint(SELF + "found a reaction "
					+ " number for a stage that had one already.");
			throw new SynthError("A single box may not contain "
					+ "more than one reaction number.  If you wish "
					+ "to run more than one reaction on a compound, "
					+ "draw the product of the first reaction in its "
					+ "own box, and then put the number of the "
					+ "next reaction in that next box. ");
		} // if more than one number in this stage
		debugPrint(SELF + "stage with box index ",
				getBoxIndex() + 1, " is subjected to "
				+ "reaction condition in position ", rxnPosn);
		// get rxn condition ID corresponding to number in textbox
		if (MathUtils.inRange(rxnPosn, conditionsRange)) {
			final int conditionId =
					MathUtils.parseInt(conditions[rxnPosn - 1]);
			setRxnCondition(conditionId);
			debugPrint(SELF + "stage with box index ", 
					getBoxIndex() + 1 + "is subject to reaction "
					+ "conditions with ID number ", conditionId);
		} else debugPrint(SELF + "number ", rxnPosn, " in textbox does "
				+ "not correspond to any reaction condition's position.");
	} // setRxnCondition(int, String[], int[])

	//----------------------------------------------------------------------
	//					getNormalizedMols
	//----------------------------------------------------------------------
	/** Get an array of copies of normalized versions of all molecules in
	 * this stage.
	 * @return	array of normalized molecules
	 */
	public Molecule[] getNormalizedMols() {
		if (Utils.isEmpty(normalizedMols)) normalizeAll();
		final Molecule[] copies = new Molecule[getNumMolecules()];
		int molNum = 0;
		for (final Molecule mol : normalizedMols) {
			copies[molNum++] = mol.clone();
		} // for each molecule
		return copies;
	} // getNormalizedMols();
	
	/** Generate normalized copies of the molecules of this stage. */
	private void normalizeAll() {
		final int numMols = getNumMolecules();
		debugPrint("SynthStage.normalizeAll: normalizing each of ",
				numMols, " molecule(s) in this stage for the first time.");
		normalizedMols = new Molecule[numMols];
		int molNum = 0;
		for (final Molecule mol : molecules) {
			normalizedMols[molNum++] = Normalize.normalize(mol);
		} // for each molecule
	} // normalizeAll()

	//--------------------------------------------------------------------------
	//					getEnumStereos
	//--------------------------------------------------------------------------
	/** Get a list of enumerated stereoisomers of the normalized molecules in
	 * this stage.
	 * @return	list of enumerated steroisomers of the normalized molecules
	 */
	List<Molecule> getEnumStereos() {
		if (enumStereos.isEmpty()) {
			enumerateStereoisomers();
		} // if there are no enumerated stereoisomers
		final List<Molecule> copy = new ArrayList<Molecule>();
		copy.addAll(enumStereos);
		return copy;
	} // getEnumStereos()

	/** Enumerate the stereoisomers of the normalized molecules of this stage. */
	private void enumerateStereoisomers() {
		final int numMols = getNumMolecules();
		debugPrint("SynthStage.enumerateStereoisomers: "
				+ "enumerating the stereoisomers of ", numMols,
				" normalized molecules in this stage for the first time.");
		// enumerate the stereoisomers, label enumerated
		for (final Molecule normMol : getNormalizedMols()) {
			final List<Molecule> stereoisomers =
					StereoFunctions.enumerateStereo(normMol);
			final int numEnumerated = stereoisomers.size();
			if (numEnumerated == 1) {
				debugPrint("   ", normMol, " gave no enumerated stereoisomers.");
				enumStereos.add(normMol);
			} else {
				debugPrint("   ", normMol, " gave ", numEnumerated,
						" enumerated stereoisomer(s): ", stereoisomers);
				for (int isoNum = 0; isoNum < numEnumerated; isoNum++) {
					final Molecule stereo = stereoisomers.get(isoNum);
					// mark each stereoisomer as coming from a single original
					// submission
					stereo.setProperty(EXPANDED_STEREOISOMER,
							Utils.toString(numMols + 1, ':', isoNum + 1));
					enumStereos.add(stereo);
				} // for each stereoisomer of the original molecule
			} // if the original molecule had to be expanded into its isomers
		} // for each normalized molecule
	} // enumerateStereoisomers()

	//--------------------------------------------------------------------------
	//							getFusedMolecule
	//--------------------------------------------------------------------------
	/** Gets all this stage's molecules fused into a single Molecule object.
	 * @return	a Molecule containing all of this stage's molecules
	 */
	Molecule getFusedMolecule() {
		final Molecule fMol = new Molecule();
		final int numMols = getNumMolecules();
		for (final Molecule mol : getNormalizedMols()) fMol.fuse(mol); // already a copy
		fMol.setProperty(SynthSolver.ORIG_MOL_COUNT, String.valueOf(numMols));
		return fMol;
	} // getFusedMolecule()

	//--------------------------------------------------------------------
	//  					getMaxPrevLinearSteps
	//--------------------------------------------------------------------
	/** Gets the longest linear sequence of steps up to this stage.  Called
	 * recursively.
	 * @return	longest linear sequence up to this stage
	 */
	int getMaxPrevLinearSteps() {
		int maxPrevSteps = -1;
		for (final SynthStage prevStage : prevStages) {
			final int prevSteps = prevStage.getMaxPrevLinearSteps();
			if (prevSteps > maxPrevSteps) maxPrevSteps = prevSteps;
		} // for each previous stage
		debugPrint("SynthStage.getMaxPrevLinearSteps: "
				+ "stage with box #", getBoxIndex() + 1,
				" has ", maxPrevSteps + 1, " maximum previous steps.");
		return maxPrevSteps + 1;
	} // getMaxPrevLinearSteps()

	//----------------------------------------------------------------------
	//					calculateRxnProducts
	//----------------------------------------------------------------------
	/** Calculates and stores products of this stage's molecules and
	 * reaction conditions.  Stores rxnIsAsymmetric. Catches SynthErrors and
	 * sets rxnStatus accordingly.
	 */
	void calculateRxnProducts() {
		final String SELF = "SynthStage.calculateRxnProducts: ";
		debugPrint(SELF + "starting...");
		try {
			final SynthSolver solver = new SynthSolver();
			final Molecule submitMol = getFusedMolecule();
			debugPrint(SELF + "Submitting ", submitMol,
					" to SynthSolver for calculation of products.");
			calculatedProds = solver.getProducts(submitMol, rxnCondition);
			if (!Utils.isEmpty(calculatedProds)) {
				debugPrint(SELF + "got back ", calculatedProds.length, 
						" calculated product(s): ", calculatedProds);
				for (final Molecule calcProd : calculatedProds) {
					if (calcProd.getDim() == 0) {
						StereoFunctions.convert0DTo2D(calcProd);
					} // if dimensionality is 0
					Normalize.normalizeNoClone(calcProd);
				} // for each calculated product of this stage
				debugPrint(SELF + "after converting to 2D (if necessary) "
						+ "and normalization, calculated product(s) are: ", 
						calculatedProds);
				rxnStatus = RXNS_OK;
				rxnIsAsymmetric = solver.didAsymmetricRxn;
			} else {
				debugPrint(SELF + "got back no reaction products.");
				rxnStatus = NO_RXN_PRODUCTS;
			}
		} catch (SynthError e) {
			debugPrint(SELF + "caught SynthError ",
					e.errorNumber, "; no reaction products.");
			rxnStatus = e.errorNumber;
		}
	} // calculateRxnProducts()

	//--------------------------------------------------------------------
	//  				checkValidRxnProducts
	//--------------------------------------------------------------------
	/** For this stage, is its contents composed of starting materials
	 * and products of reactions of the previous stages?
	 * @throws	SynthError	if this stage contains contents that are neither
	 * permissible starting materials nor produced by reactions
	 */
	void checkValidRxnProducts() throws SynthError {
		final String SELF = "SynthStage.checkValidRxnProducts: ";
		// We'll remove stage molecules from stageCpds as we find
		// they are produced in previous stages, leaving only response SMs.
		// If there are no previous stages, stageCpds is all molecules in
		// the stage.
		final List<Molecule> stageCpds = getEnumStereos();
		final List<Molecule> areRxnProducts = new ArrayList<Molecule>();
		boolean plural;
		if (hasPrevStage()) {
			// recursively check each previous stage for good rxn products
			for (final SynthStage prevStage : prevStages) {
				prevStage.checkValidRxnProducts();
			} // for each previous stage
			// if no errors thrown, see if rxn of each previous stage gives
			// a molecule in this stage
			debugPrint(SELF + "Current stage with box #",
					boxIndex + 1, " contains enumerated "
					+ "stereoisomeric compounds: ", stageCpds);
			try {
				for (int prevIdx = 0; prevIdx < prevStages.size(); prevIdx++) {
					final SynthStage prevStage = prevStages.get(prevIdx);
					if (prevStage.getRxnStatus() == UNCHECKED) {
						prevStage.calculateRxnProducts();
					}
					if (prevStage.getRxnStatus() == NO_RXN_PRODUCTS) {
						debugPrint(SELF + "Reaction of previous stage ",
								prevIdx + 1, " with box #",
								prevStage.getBoxIndex() + 1,
								" gives no products.");
						throwSynthError(prevStage.getBoxIndex(),
								NO_RXN_PRODUCTS);
					} // if there are no rxn products from the previous stage
					if (prevStage.getRxnStatus() != RXNS_OK) {
						throwSynthError(prevStage.getBoxIndex(),
								prevStage.getRxnStatus());
					} // if something went wrong with the product calculation
					final Molecule[] prevStageRxnProds =
							prevStage.getRxnProducts();
					debugPrint(SELF + "Previous stage ", prevIdx + 1, 
							" of stage with box #", boxIndex + 1, 
							" has ", prevStageRxnProds.length,
							" product(s) ", prevStageRxnProds);
					debugPrintMRV("or:\n", prevStageRxnProds);
					// look for at least one product of previous reaction
					// in this stage; if it's found, remove it from stageCpds
					Molecule foundProd = null;
					boolean foundProdIsMinor = true;
					String minorExplan = "";
					plural = (stageCpds.size() != 1);
					debugPrint(SELF + "There ", (plural ? "are " : "is "), 
							stageCpds.size(), " compound", (plural ? "s" : ""),
							" in current stage: ", stageCpds,
							"; removing products of previous stage.");
					int prevStgProdIdx = 0;
					for (final Molecule thisProd : prevStageRxnProds) {
						// first, flag as racemic, molecules of this stage that
						// match to calculated products flagged as racemic;
						// needed so that racemic diastereopure compounds in
						// this stage that undergo future reactions give 
						// racemic products
						final boolean isFlaggedRacemic =
								StereoFunctions.isFlaggedRacemic(thisProd);
						if (isFlaggedRacemic) {
							debugPrint(SELF + "calculated product ",
									thisProd, " of previous stage ",
									prevIdx + 1, " is flagged as racemic");
							final int prodArrayIdx = SynthSet.molInArray(
									thisProd, getNormalizedMols());
							if (prodArrayIdx != NOT_FOUND) {
								debugPrint(SELF + "normalized molecule ", 
										normalizedMols[prodArrayIdx],
										" of current stage matches; "
										+ "flag it as racemic as well.");
								normalizedMols[prodArrayIdx]
										.setProperty(RACEMIZE, TRUE);
							} // if calcd product is found among normalized molecules
						} // if calcd product is flagged as racemic
						final int numTimes = (isFlaggedRacemic ? 2 : 1);
						for (int time = 0; time < numTimes; time++) {
							// is calculated product found among enumerated
							// stereoisomers of this stage?
							final Molecule thisProdOrEnant = (time == 0 
									? thisProd : ChemUtils.getMirror(thisProd));
							debugPrint(SELF + "Checking whether ",
									(time == 0 ? "" : "enantiomer of racemic "),
									"calculated product ", ++prevStgProdIdx, 
									", ", thisProdOrEnant, 
									" (with dimension ", thisProdOrEnant.getDim(),
									") of the previous "
									+ "stage is in the present one.");
							int prodArrayIdx = NOT_FOUND;
							prodArrayIdx = SynthSet.molInArray(thisProdOrEnant, 
									stageCpds);
							if (prodArrayIdx != NOT_FOUND) {
								debugPrint(SELF + "Found calculated product ",
										prevStgProdIdx, " of previous stage ",
										prevIdx + 1, " in current stage; "
										+ "removing from stageCpds.");
								foundProd = stageCpds.remove(prodArrayIdx);
								foundProd.setProperty("Producing stage box index",
										Integer.toString(
												prevStage.getBoxIndex()));
								areRxnProducts.add(foundProd);
								// find out if found product has major/minor info stored
								final String majorMinor =
										ChemUtils.getProperty(foundProd, MAJ_MIN_PROD);
								if (MINOR.equals(majorMinor)) {
									debugPrint(SELF 
											+ "Found product is a minor one.");
									minorExplan = ChemUtils.getProperty(foundProd, 
											MAJ_MIN_EXPLAN);
								} else {
									debugPrint(SELF 
											+ "Found product is a major one.");
									foundProdIsMinor = false;
								} // if found product is major
								debugPrint(SELF + "Removed ", foundProd, 
										" from stageCpds; remaining are ", 
										stageCpds);
							} else {
								debugPrint(SELF + "Did not find calculated "
										+ "product ", prevStgProdIdx, " of "
										+ "previous stage in the current stage.");
							} // if the calcd product is in the current stage
						} // for the calcd product and maybe its enantiomer
					} // for each product of the previous stage
					if (foundProd == null) {
						debugPrint(SELF + "Did not find any product of previous stage ", 
								prevIdx + 1, " in current stage.");
						// see if an enantiomer can be found, for better feedback
						prevStgProdIdx = 0;
						for (final Molecule prevStgProd : prevStageRxnProds) {
							debugPrint(SELF + "Checking whether the enantiomer of product ", 
									++prevStgProdIdx, ", ", prevStgProd,
									", of the previous stage is in the present one.");
							int prodArrayIdx = NOT_FOUND;
							prodArrayIdx = SynthSet.molInArray(
									ChemUtils.getMirror(prevStgProd), stageCpds);
							if (prodArrayIdx != NOT_FOUND) {
								debugPrint(SELF + "Found enantiomer of product ",
										prodArrayIdx + 1, " of previous stage ",
										prevIdx + 1, " in current stage.");
								throwSynthError(prevStage.getBoxIndex(),
										WRONG_ENANTIOMER);
							} // if found product of previous stage in current stage
						} // for each product of the previous stage
						// see if a diastereomer can be found, for better feedback
						prevStgProdIdx = 0;
						for (final Molecule prevStgProd : prevStageRxnProds) {
							debugPrint(SELF + "Checking whether a diastereomer of product ", 
									++prevStgProdIdx, ", ", prevStgProd,
									", of the previous stage is in the present one.");
							int prodArrayIdx = NOT_FOUND;
							prodArrayIdx = SynthSet.molInArray(prevStgProd,
									stageCpds, TOLERATE_ANY_STEREO);
							if (prodArrayIdx != NOT_FOUND) {
								debugPrint(SELF + "Found a diastereomer of product ", 
										prodArrayIdx + 1, " of previous stage ", 
										prevIdx + 1, " in current stage.");
								throwSynthError(prevStage.getBoxIndex(),
										WRONG_DIASTEREOMER);
							} // if found product of previous stage in current stage
						} // for each product of the previous stage
						// if couldn't find enantiomer or diastereomer, just throw
						// generic "can't find products" error
						stdizeCalcdProds(prevStageRxnProds);
						debugPrint(SELF + "Couldn't find a stereoisomer of "
								+ "previous stage's products in this stage.  "
								+ "prevStageRxnProds are ", prevStageRxnProds);
						final String calcdProds = 
								Utils.molArrayToString(prevStageRxnProds);
						throwSynthError(prevStage.getBoxIndex(),
								NO_PRODS_IN_NEXT_STAGE, calcdProds);
					} else if (foundProdIsMinor) { // only minor product has been found
						debugPrint(SELF + "The current stage contains only a minor "
								+ "product of previous stage ", prevIdx + 1, ".");
						throwSynthError(prevStage.getBoxIndex(),
								MINOR_PRODUCT, minorExplan);
					} // if a product was or wasn't found
				} // for each previous stage
			} catch (SearchException e) {
				debugPrint(SELF + "Threw a SearchException when looking at "
						+ "whether any reaction products from previous "
						+ "stage are present in current stage.");
				throwSynthError(SEARCH_EXCEPTION);
			} // try
		} else { // no previous stages
			debugPrint(SELF + "Stage with box #",
					boxIndex + 1, " has no previous stages; "
					+ "these stage contents must be only "
					+ "starting materials: ", stageCpds);
		} // if stage has previous stages
		plural = (stageCpds.size() != 1);
		debugPrint(SELF + "There ", (plural ? "are " : "is "),
				stageCpds.size(), " compound", (plural ? "s" : ""),
				" in current stage that ", (plural ? "are" : "is"), " not ",
				(plural ? "products" : "a product"), " of previous stages: ",
				stageCpds);
		// set the starting materials of this stage if not already set
		if (!areStartersDetermined()) {
			setStarters(stageCpds);
			setNotStarters(areRxnProducts);
			setStartersDetermined(true);
		} // if starting materials of this stage haven't yet been set
		// now see if any remaining compounds are permissible starting
		// materials
		if (stageCpds.isEmpty()) {
			debugPrint(SELF + "No potential SMs to analyze for permissibility.");
		} else { // not empty
			debugPrint(SELF + "Removing permissible starting materials from ",
					stageCpds.size(), " compound(s) in current stage that are "
					+ "not products of previous stages: ", stageCpds);
			removePermissibleSMs(stageCpds);
			final int numRemainingStageCpds = stageCpds.size();
			plural = (numRemainingStageCpds != 1);
			debugPrint(SELF + numRemainingStageCpds, " compound", (plural ? "s" : ""), 
					" in stage ", (plural ? "are" : "is"), " neither ",
					(plural ? "products" : "a product"),
					" of a previous stage nor ", (plural ? "" : "a "),
					"permissible starting material",
					(plural ? "s" : ""), ": ", stageCpds);
			if (numRemainingStageCpds > 0) {
				// find out whether any of the impermissible SMs are
				// ACE-generated stereoisomers of compounds that were
				// found among calculated products
				for (final Molecule stageCpd : stageCpds) {
					final String stageCpdStereoDerivInfo =
							ChemUtils.getProperty(stageCpd, EXPANDED_STEREOISOMER);
					if (stageCpdStereoDerivInfo != null) {
						final String stageCpdStereoDerivNum =
								stageCpdStereoDerivInfo.split(":")[0];
						for (final Molecule calcdRxnProd : areRxnProducts) {
							final String rxnProdStereoDerivInfo =
									ChemUtils.getProperty(calcdRxnProd, 
										EXPANDED_STEREOISOMER);
							if (rxnProdStereoDerivInfo == null) continue;
							if (rxnProdStereoDerivInfo.split(":")[0].equals(
										stageCpdStereoDerivNum)) {
								debugPrint(SELF + "'Impermissible SM' ", stageCpd,
										" was an ACE-generated stereoisomer of ",
										calcdRxnProd);
								throwSynthError(UNSPECIFIED_STEREOISOMERS);
							} // if the two compounds are stereoisomers
								// generated from the same user compound
						} // for each verified rxn product
					} // if the "impermissible SM" was a stereoisomer produced
						// by expansion of a cpd of unspecified configuration
				} // for each remaining "impermissible SM"		
				debugPrint(SELF + "None of the 'impermissible SMs' "
						+ "are ACE-generated stereoisomers of any "
						+ "found products.");
				if (isTargetStage()) throwSynthError(LAST_NOT_RXN_PRODUCT);
				else throwSynthError(hasPrevStage() 
							? CONTAINS_IMPERMISSIBLE_SM
							: START_STAGE_HAS_IMPERMISSIBLE_SM);
			} // if there are impermissible SMs
		} // not empty
		debugPrint(SELF + "Analysis of stage with box #", 
				boxIndex + 1, " is complete; everything seems OK.");
	} // checkValidRxnProducts()

	//----------------------------------------------------------------------
	//					removePermissibleSMs
	//----------------------------------------------------------------------
	/** Removes from a list of compounds all those that are permissible starting
	 * materials.
	 * @param	respSMs	compounds in the response not produced by reactions
	 * in previous steps
	 * @throws	SynthError	if a response starting material is an impossible
	 * compound
	 */
	private void removePermissibleSMs(List<Molecule> respSMs) 
			throws SynthError {
		final String SELF = "SynthStage.removePermissibleSMs: ";
		debugPrint(SELF, respSMs.size(),
				" response starting material(s) counted.");
		for (int smNum = respSMs.size() - 1; smNum >= 0; smNum--) {
			final Molecule respSM = respSMs.get(smNum);
			if (parentSynth.isPermissibleSM(respSM)) {
				debugPrint(SELF, respSM,
						" is permissible; check if impossible.");
				isBadSM(respSM); // throws error if true
				debugPrint(SELF, respSM, " not impossible.");
				respSMs.remove(smNum);
			} // if the compound is a permissible SM
		} // for each permissible SM
	} // removePermissibleSMs(List<Molecule>)

	//--------------------------------------------------------------------
	//  				isBadSM
	//--------------------------------------------------------------------
	/** Determines whether a compound is an impossible starting material as 
	 * defined by SynthBadSMs.
	 * @param	mol	the compound
	 * @return	false if the compound is not an impossible starting material
	 * @throws	SynthError	if the compound is an impossible starting material;
	 * message contains the name of the offending substructure
	 */
	public boolean isBadSM(Molecule mol) throws SynthError {
		final String SELF = "SynthStage.isBadSM: ";
		final NamedCompound[] badSMs = parentSynth.getBadSMs();
		for (final NamedCompound badSM : badSMs) {
			try {
				final boolean isImpossible = MolCompare.containsSubstruct(
						ChemUtils.stripMetals(mol), badSM.mol);
				if (isImpossible) {
					// combine offending cpd with name of offending structure
					final String smiles = Utils.toString(
							MolString.toString(mol, SMILES), '\t', badSM.name);
					debugPrint(SELF + "throwing SynthError for "
							+ "impossible SM ", smiles);
					throwSynthError(BAD_SM, smiles);
				} // if SM is impossible
			} catch (MolCompareException e) {
				debugPrint(SELF + "can't happen");
			} // try
		} // for each impossible Molecule
		return false;
	} // isBadSM(Molecule)

	//----------------------------------------------------------------------
	//					noRespProductsArePermissibleSMs
	//----------------------------------------------------------------------
	/** Determines whether any of the response products in this stage are 
	 * permissible starting materials.  Called recursively.
	 * @return	true if none of the response products are permissible starting
	 * materials.
	 * @throws	SynthError	if any of the response products are permissible starting
	 * materials.
	 */
	boolean noRespProductsArePermissibleSMs() throws SynthError {
		final String SELF = "SynthStage.noRespProductsArePermissibleSMs: ";
		debugPrint("Entering " + SELF + "with stage with box #", 
				boxIndex + 1, ".");
		// We'll remove stage molecules from stageCpds as we find
		// they are produced in previous stages, leaving only response SMs.
		// If there are no previous stages, stageCpds is all molecules in
		// the stage.
		if (hasPrevStage()) {
			final int size = prevStages.size();
			debugPrint(SELF + "Looking recursively at previous ", size, 
					" stage(s) of current stage with box #", boxIndex + 1, ".");
			// recursively check each previous stage for good rxn products
			for (final SynthStage prevStage : prevStages) {
				final boolean prevOK = 
						prevStage.noRespProductsArePermissibleSMs();
				if (!prevOK) return false;
			} // for each previous stage
			debugPrint(SELF + "Exiting recursive look at previous ", size, 
					" stage(s) of current stage with box #", boxIndex + 1, ".");
		} else debugPrint(SELF + "Current stage with box #",
				boxIndex + 1,
				" has no previous stages to examine recursively.");
		// don't check for permissible SMs in target stage
		if (isTargetStage()) {
			debugPrint(SELF + "Current stage with box #",
					boxIndex + 1, " is the target stage; don't examine.");
			return true;
		} else debugPrint(SELF + "Current stage with box #",
				boxIndex + 1, " is not the target stage; examine "
				+ "for products that are permissible starting materials.");
		final List<Molecule> notStarters = getNotStarters();
		final int numNotStarters = Utils.getSize(notStarters);
		if (numNotStarters > 0) {
			debugPrint(SELF + "Stage with box #", boxIndex + 1,
					" contains ", numNotStarters, " compound(s)"
					+ " produced in reactions of prior stages.");
			for (final Molecule respProd : notStarters) {
				if (parentSynth.isPermissibleSM(respProd)) {
					debugPrint(SELF + "Response product ", respProd, 
							" in stage with box #", boxIndex + 1,
							" is a permissible starting material.");
					throwSynthError(RXN_PROD_IS_OK_SM);
				} else debugPrint(SELF + "Response product ", respProd, 
						" in stage with box #", boxIndex + 1,
						" is not a permissible starting material.");
			} // for each response product
			debugPrint(SELF + "None of the response products in stage "
					+ "with box #", boxIndex + 1,
					" are permissible starting materials.");
		} else debugPrint(SELF + "The stage with box #",
				boxIndex + 1, " contains no products of prior stages.");
		return true;
	} // noRespProductsArePermissibleSMs()

	//----------------------------------------------------------------------
	//					isSelective
	//----------------------------------------------------------------------
	/** Gets whether the reaction of the previous stage is selective for the
	 * products of this stage.  Called recursively.  A synthesis is:
	 * <ul>
	 * <li>enantioselective if the previous stage does not produce both
	 * enantiomers of that compound;
	 * <li>diastereoselective if the previous stage does not also produce a
	 * diastereomer of that compound as a major product;
	 * <li>structure-selective if the previous stage does not also produce
	 * another major product in a different Reactor calculation.
	 * </ul>
	 * @param	kind	whether to examine the synthesis for structure-,
	 * diastereo-, or enantioselectivity
	 * @param	stepOK	a reaction whose lack of selectivity should not cause
	 * an error to be thrown
	 * @throws	SynthError	if this stage fails to show the kind
	 * of selectivity being examined
	 */
	void isSelective(int kind, Synthesis stepOK) throws SynthError {
		final String SELF = "SynthStage.isSelective: ";
		final List<Molecule> stageCpds = getEnumStereos();
		final int numCpds = stageCpds.size();
		debugPrint(SELF + "Checking stage with box #",
				boxIndex + 1, ", which contains ", numCpds,
				" enumerated stereoisomer(s) ", stageCpds, ", for ",
				(kind == SynthSelective.ENANTIO ? "enantio"
					: kind == SynthSelective.DIASTEREO ? "diastereo"
					: "structure-"), "selectivity.");
		if (hasPrevStage()) {
			int prevIdx = 0;
			for (final SynthStage prevStage : prevStages) {
				if (prevStage.getRxnStatus() == UNCHECKED) { // unlikely
					prevStage.calculateRxnProducts();
				} // if reaction products of previous stage were not yet calculated
				if (prevStage.getRxnStatus() != RXNS_OK) { // unlikely
					throwSynthError(prevStage.getBoxIndex(),
							prevStage.getRxnStatus());
				} // if reaction products of previous stage couldn't be calculated
				final Molecule[] prevStageRxnProds = prevStage.getRxnProducts();
				if (Utils.isEmpty(prevStageRxnProds)) { // unlikely
					debugPrint(SELF + "Previous stage ",
							prevIdx + 1, " has no products.");
					throwSynthError(prevStage.getBoxIndex(), NO_RXN_PRODUCTS);
				} // if there were no reaction products of previous step
				final int numPSRP = prevStageRxnProds.length;
				debugPrint(SELF + "Previous stage ", prevIdx + 1, " has ", 
						numPSRP, (numPSRP == 1 ? " product: " : " products: "),
						prevStageRxnProds);
				debugPrintMRV("or:\n", prevStageRxnProds);
				// look for at least one product of previous reaction
				// in this stage
				int prevStgProdIdx = 0; 
				for (final Molecule calcdProd : prevStageRxnProds) {
					try {
						final int prodArrayIdx = 
								SynthSet.molInArray(calcdProd, stageCpds);
						if (prodArrayIdx != NOT_FOUND) {
							debugPrint(SELF + "Previous stage ", prevIdx + 1,
									" produces current stage compound ",
									calcdProd, " ...");
							prevStage.checkSelectivity(kind, prevIdx,
									prevStgProdIdx, prodArrayIdx, stepOK);
						} else {
							debugPrint(SELF + "Current stage does not "
									+ "contain product ", calcdProd,
									" of previous stage ", prevIdx + 1, ".");
						} // if product of previous stage is in current stage
					} catch (SearchException e) {
						debugPrint(SELF + "Threw a SearchException when "
								+ "looking at whether any reaction products from "
								+ "previous stage are present in current stage.");
					} catch (MolCompareException e) {
						Utils.alwaysPrint(SELF + "MolCompareException thrown and "
								+ "caught while getting enantiomer of ",
								calcdProd, "; ignore and keep going.");
					} // try
					prevStgProdIdx++;
				} // for each calculated product of the previous stage
				prevIdx++;
			} // for each previous stage
			debugPrint(SELF + "No more previous stages to check; "
					+ "selectivity of this stage appears to be good.");
			for (final SynthStage prevStage : prevStages) {
				prevStage.isSelective(kind, stepOK);
			} // for each previous stage
		} else debugPrint(SELF + "The current stage, which has box #",
				boxIndex + 1, ", does not have a previous stage.");
	} // isSelective(int, Synthesis)

	//----------------------------------------------------------------------
	//					checkSelectivity
	//----------------------------------------------------------------------
	/** Determines whether the reaction of this stage is selective
	 * for a particular calculated product.  Utility method for isSelective().
	 * @param	kind	whether to examine the synthesis for structure-,
	 * diastereo-, or enantioselectivity
	 * @param	prevIdx	this stage's index among previous stages of the next
	 * stage; needed for debugging output only
	 * @param	calcdProdIdx	index of the calculated product in the reaction
	 * products of this stage
	 * @param	stageProdIdx	index of the drawn product in the next stage
	 * to which the calculated product matches
	 * @param	stepOK	a reaction whose lack of selectivity should not cause
	 * an error to be thrown; may be null
	 * @throws	SynthError	if this stage fails to show the kind
	 * of selectivity being examined
	 * @throws	SearchException	if structures can't be compared
	 * @throws	MolCompareException	if structures can't be compared
	 */
	void checkSelectivity(int kind, int prevIdx, int calcdProdIdx, 
			int stageProdIdx, Synthesis stepOK) 
			throws SynthError, SearchException, MolCompareException {
		final String SELF = "SynthStage.checkSelectivity: ";
		final Molecule calcdProd = calculatedProds[calcdProdIdx];
		debugPrintMRV(SELF + "looking at calcdProd:\n", calcdProd);
		if (stepOK != NO_STEPOK) { // pointer equality
			if (oneStepIs(stepOK, SynthOneRxn.IS, !RECURSE)) {
				debugPrint(SELF + "   ... the present reaction "
						+ "matches the excluded one.");
				return;
			} else debugPrint(SELF + "   ... the present reaction "
					+ "does not match the excluded one ...");
		} // if there is an excluded reaction
		if (kind == SynthSelective.ENANTIO) {
			final Molecule calcdProdMirror = ChemUtils.getMirror(calcdProd);
			if (!MolCompare.matchPrecise(calcdProd, calcdProdMirror)) {
				// calcdProd is chiral
				if (SynthSet.molInArray(calcdProdMirror,
						calculatedProds) != NOT_FOUND) {
					debugPrint("   ... and it also produces "
							+ "its enantiomer!  Throwing SynthError.");
					final int errorNum = 
							getEnantioErrorNum(calcdProd, calcdProdMirror);
					debugPrint(SELF + "The enantiomer of the found "
							+ "product ", calcdProd, " is produced "
							+ "in equal amounts! Throwing SynthError "
							+ "with errorNum ", errorNum);
					stdizeCalcdProds(calculatedProds);
					throwSynthError(errorNum, 
							Utils.molArrayToString(calculatedProds));
				} else debugPrint("   ... but the enantiomer ",
						calcdProdMirror, " is not also produced.");
			} else debugPrint("   ... but this compound is achiral.");
		} else if (kind == SynthSelective.DIASTEREO) {
			// find out if calculated product has major/minor info stored
			final String majorMinor = 
					ChemUtils.getProperty(calcdProd, MAJ_MIN_PROD);
			debugPrint(SELF + "majorMinor property of ", calcdProd, " = ",
					majorMinor);
			if (!MINOR.equals(majorMinor)) {
				// see if a diastereomer of calculated prod is also
				// found among the calculated products
				final int numCalcdProds = calculatedProds.length;
				for (int calcdProdIdx2 = 0;
						calcdProdIdx2 < numCalcdProds; calcdProdIdx2++) {
					if (calcdProdIdx2 == calcdProdIdx)
						continue; // don't compare to itself
					final Molecule compare = calculatedProds[calcdProdIdx2];
					try {
						final boolean areSameOrStereo =
								MolCompare.matchExact(calcdProd,
									compare, IGNORE_STEREO);
						final Molecule calcdProdMirror = 
								ChemUtils.getMirror(calcdProd);
						final boolean notEnant = !MolCompare.matchExact(
								calcdProdMirror, compare, WAVY_XOR);
						debugPrint(SELF + "Comparing ", calcdProd, 
								" and its mirror image ", calcdProdMirror,
								" to ", compare, ": areSameOrStereo = ", 
								areSameOrStereo, ", notEnant = ", notEnant);
						if (areSameOrStereo && notEnant) {
							debugPrint(SELF + "Also found a diastereomer ", 
									compare, " of the found product ", 
									calcdProd, " among the calculated products.");
							final String diastMajorMinor = 
									ChemUtils.getProperty(compare, MAJ_MIN_PROD);
							debugPrint(SELF + "majorMinor property of ", 
									compare, " = ", diastMajorMinor);
							if (!MINOR.equals(diastMajorMinor)) {
								final int errorNum = 
										getDiastereoErrorNum(calcdProd, compare);
								debugPrint(SELF + "A diastereomer ", compare, 
										" of the found product ", calcdProd,
										" is produced in equal amounts! "
										+ "Throwing SynthError with errorNum ", 
										errorNum);
								stdizeCalcdProds(calculatedProds);
								throwSynthError(errorNum, 
										Utils.molArrayToString(calculatedProds));
							} else debugPrint(SELF + "The diastereomer ",
									compare, " is produced only in minor amounts.");
						} else debugPrint(SELF + "Did not find a diastereomer ",
								compare, " of the found product ", calcdProd,
								" among the calculated products.");
					} catch (MolCompareException e) {
						Utils.alwaysPrint(SELF + "MolCompareException thrown and "
								+ "caught while comparing ", calcdProd, " to ",
								compare, "; ignore and keep going.");
					} // try
				} // for each cpd calcdProdIdx2 in calculated products
			} else debugPrint(SELF + "Calculated product ", calcdProdIdx + 1, 
					", ", calcdProd, ", of previous stage ", prevIdx + 1, 
					" is not a major product.");
		} else { // SynthSelective.ANY (structure-selective)
			final String calcdProdMajorMinor = 
					ChemUtils.getProperty(calcdProd, MAJ_MIN_PROD);
			if (!MINOR.equals(calcdProdMajorMinor)) {
				final String calcdProdReactorIdxStr =
						ChemUtils.getProperty(calcdProd, REACTOR_INDEX);
				final int calcdProdReactorIdx =
						MathUtils.parseInt(calcdProdReactorIdxStr);
				debugPrint(SELF + "Calculated product ", calcdProdIdx + 1, 
						", ", calcdProd, ", of previous stage ", prevIdx + 1,
						" is a major product; reactor index ",
						calcdProdReactorIdx, ".");
				final int numCalcdProds = calculatedProds.length;
				for (int calcdProdIdx2 = 0;
						calcdProdIdx2 < numCalcdProds; calcdProdIdx2++) {
					if (calcdProdIdx2 == calcdProdIdx)
						continue; // don't compare to itself
					final Molecule compare = calculatedProds[calcdProdIdx2];
					final String compareMajorMinor = 
							ChemUtils.getProperty(compare, MAJ_MIN_PROD);
					if (!MINOR.equals(compareMajorMinor)) {
						final String compareReactorIdxStr = 
								ChemUtils.getProperty(compare, REACTOR_INDEX);
						final int compareReactorIdx =
								MathUtils.parseInt(compareReactorIdxStr);
						debugPrint(SELF + "Calculated product ", calcdProdIdx2 + 1,
								", ", compare, ", of previous stage ", prevIdx + 1,
								" is also a major product; reactor index ",
								compareReactorIdx, ".");
						if (compareReactorIdx != calcdProdReactorIdx) {
							// Reactor produced major products over > 1 cycle, a
							// sure sign of an unselective reaction
							debugPrint(SELF + "More than one major product is "
									+ "produced in different Reactor cycles; "
									+ "reaction appears " + "to be unselective! "
									+ "Throwing SynthError.");
							stdizeCalcdProds(calculatedProds);
							throwSynthError(UNSELECTIVE, 
									Utils.molArrayToString(calculatedProds));
						} // if another prod was from a different Reactor cycle
					} else debugPrint(SELF + "Calculated product ", 
							calcdProdIdx2 + 1, ", ", compare, ", of previous "
							+ "stage ", prevIdx + 1, " is not a major product.");
				} // for each cpd calcdProdIdx2 in calculated products
			} else debugPrint(SELF + "Calculated product ",
					calcdProdIdx + 1, ", ", calcdProd, ", of previous stage ",
					prevIdx + 1, " is not a major product.");
		} // if kind
	} // checkSelectivity(int, int, int, Synthesis)

	/** For a nondiastereoselective step, is the diastereomer shown 
	 * in the next stage, and is it distinguished from the calculated 
	 * product?
	 * @param	calcdProd	the calculated product
	 * @param	diast	the diastereomer
	 * @return	appropriate error number
	 * @throws	SearchException	if structures can't be compared
	 */
	private int getDiastereoErrorNum(Molecule calcdProd, Molecule diast) 
			throws SearchException {
		final String SELF = "SynthStage.getDiastereoErrorNum: ";
		final Molecule[] nextStageCpds = nextStage.getNormalizedMols();
		final int diastOrigIdx = 
				SynthSet.molInArray(diast, nextStageCpds);
		if (diastOrigIdx == NOT_FOUND) {
			debugPrint(SELF + "Molecules of next stage are ", 
					nextStageCpds, "; diastereomer ", diast, 
					" is not found."); 
			return UNDIASTEREOSELECTIVE_NOT_SHOWN;
		} // if diastereomer is not shown in next stage
		final int calcdProdIdx = 
				SynthSet.molInArray(calcdProd, nextStageCpds);
		debugPrint(SELF + "Molecules of next stage are ", nextStageCpds, 
				"; index of calculated product ", calcdProd, " is ", 
				calcdProdIdx + 1, "; index of diastereomer ", diast, 
				" is ", diastOrigIdx + 1);
		return (diastOrigIdx == calcdProdIdx 
				? UNDIASTEREOSELECTIVE_NOT_DISTING
				: UNDIASTEREOSELECTIVE_SHOWN);
	} // getDiastereoErrorNum(Molecule, Molecule)

	/** For a nonenantioselective step, is the enantiomer shown 
	 * in the next stage, and is it distinguished from the calculated 
	 * product?
	 * @param	calcdProd	the calculated product
	 * @param	enant	its enantiomer
	 * @return	appropriate error number
	 * @throws	MolCompareException	if structures can't be compared
	 * @throws	SearchException	if structures can't be compared
	 */
	private int getEnantioErrorNum(Molecule calcdProd, Molecule enant) 
			throws MolCompareException, SearchException {
		final String SELF = "SynthStage.getEnantioErrorNum: ";
		final Molecule[] nextStageCpds = nextStage.getNormalizedMols();
		final int enantOrigIdx = 
				SynthSet.molInArray(enant, nextStageCpds);
		if (enantOrigIdx == NOT_FOUND) {
			debugPrint(SELF + "Molecules of next stage are ", 
					nextStageCpds, "; enantiomer ", enant, 
					" is not found."); 
			return UNENANTIOSELECTIVE_NOT_SHOWN;
		} // if enantiomer is not shown in next stage
		final boolean stageCpdIsRacemic = 
				MolCompare.matchExact(calcdProd,
					nextStageCpds[enantOrigIdx]);
		if (stageCpdIsRacemic) {
			debugPrint(SELF + "Molecules of next stage are ", 
					nextStageCpds, "; calculated product ", calcdProd, 
					" and enantiomer ", enant, 
					" both match to next stage compound ",
					nextStageCpds[enantOrigIdx]);
			return UNENANTIOSELECTIVE_NOT_DISTING;
		} // if stage compound is racemic
		debugPrint(SELF + "Molecules of next stage are ", nextStageCpds, 
				"; calculated product ", calcdProd, " and enantiomer ", 
				enant, " are represented by different structures.");
		return UNENANTIOSELECTIVE_SHOWN;
	} // getEnantioErrorNum(Molecule, Molecule)

	//----------------------------------------------------------------------
	//							oneStepIs
	//----------------------------------------------------------------------
	/** Determines whether this stage and the next one contain a reference
	 * synthetic step.  The reference sequence may contain whole molecules
	 * or substructures.  May be called recursively.
	 * @param	authSyn	the synthetic step that may be contained in this
	 * stage and the next one; only the last two steps are examined
	 * @param	type	whether to look for entire structures or substructures
	 * @param	recurse	true if previous stages should be examined also
	 * @return	false if the synthetic step is not found in this stage
	 * and the next one
	 * @throws	SynthError	if the synthetic step is found in this stage
	 * and the next one, or if the structures in a stage can't be compared to
	 * the structures in the author's stage
	 */
	boolean oneStepIs(Synthesis authSyn, int type, boolean recurse) 
			throws SynthError {
		final String SELF = "SynthStage.oneStepIs: ";
		if (authSyn == null) return false;
		debugPrint("Entering " + SELF
				+ "with stage with box #", boxIndex + 1, ".");
		if (recurse && hasPrevStage()) {
			final int size = prevStages.size();
			debugPrint(SELF + "Looking recursively at previous ",
					size, " stage", (size == 1 ? "" : "s"),
					" of current stage with box #",
					boxIndex + 1, ".");
			for (final SynthStage prevStage : prevStages) {
				final boolean isTheStep = 
						prevStage.oneStepIs(authSyn, type, recurse);
				if (isTheStep) return true; // won't happen
			} // for each previous stage
			debugPrint(SELF + "Exiting recursive look at previous ",
					size, " stage", (size == 1 ? "" : "s"),
					" of current stage with box #", boxIndex + 1, ".");
		} else if (recurse) debugPrint(SELF + "The current stage, "
				+ "which has box #", boxIndex + 1,
				", does not have a previous stage.");
		// assume author synthesis has only two stages
		final SynthStage authStage2 = authSyn.parsedSynth.getStage(
				authSyn.parsedSynth.targetStageIndex);
		final SynthStage authStage1 = authStage2.getAllPrevStages().get(0);
		try {
			final Molecule[] thisStageMols = getNormalizedMols();
			final Molecule[] authStage1Mols = authStage1.getNormalizedMols();
			if (type == SynthOneRxn.IS) {
				if (!SynthSet.subset(authStage1Mols, thisStageMols)) {
					debugPrint(SELF + "Not all molecules in the "
							+ "author's first stage, ", authStage1Mols,
							", are found in the current stage, which has box #",
							boxIndex + 1, " and molecules ",
							thisStageMols, ".");
					return false;
				} else debugPrint(SELF + "All molecules in the "
						+ "author's first stage, ", authStage1Mols,
						", are found in the current stage, which has box #",
						boxIndex + 1, " and molecules ",
						thisStageMols, ".");
			} else { // type == SynthOneRxn.CONTAINS
				if (!SynthSet.subsetContained(authStage1Mols, thisStageMols)) {
					debugPrint(SELF + "Not all of the substructures "
							+ "in the author's first stage, ", authStage1Mols,
							", are found in the current stage, which has box #",
							boxIndex + 1, " and molecules ",
							thisStageMols, ".");
					return false;
				} else debugPrint(SELF + "All the substructures "
						+ "in the author's first stage, ", authStage1Mols,
						", are found in the current stage, which has box #",
						boxIndex + 1, " and molecules ",
						thisStageMols, ".");
			} // if type
			final Molecule[] authStage2Mols = authStage2.getNormalizedMols();
			final SynthStage nextStage = getNextStage();
			final Molecule[] nextStageMols = nextStage.getNormalizedMols();
			if (type == SynthOneRxn.IS) {
				if (!SynthSet.subset(authStage2Mols, nextStageMols)) {
					debugPrint(SELF + "Not all molecules in the "
							+ "author's second stage, ", authStage2Mols,
							", are found in the next stage, which has box #",
							nextStage.getBoxIndex() + 1, " and molecules ",
							nextStageMols, ".");
					return false;
				} else debugPrint(SELF + "All molecules in the "
						+ "author's second stage, ", authStage2Mols,
						", are found in the next stage, which has box #",
						nextStage.getBoxIndex() + 1, " and molecules ",
						nextStageMols, ".");
			} else { // type == SynthOneRxn.CONTAINS
				if (!SynthSet.subsetContained(authStage2Mols, nextStageMols)) {
					debugPrint(SELF + "Not all of the substructures "
							+ "in the author's second stage, " , authStage2Mols,
							", are found in the next stage, which has box #",
							nextStage.getBoxIndex() + 1, " and molecules ",
							nextStageMols, ".");
					return false;
				} else debugPrint(SELF + "All of the substructures "
						+ "in the author's second stage, ", authStage2Mols,
						", are found in the next stage, which has box #",
						nextStage.getBoxIndex() + 1, " and molecules ",
						nextStageMols, ".");
			} // if type
		} catch (SearchException e) {
			debugPrint(SELF + "Threw a SearchException when comparing "
					+ "response synthesis to author synthesis.");
			throwSynthError(SEARCH_EXCEPTION);
		}
		final int authRxnCondition = authStage1.getRxnCondition();
		int thisStageRxnCondition = getRxnCondition();
		if (thisStageRxnCondition == NOT_FOUND)
			thisStageRxnCondition = NO_REAGENTS;
		final boolean isTheStep = Utils.among(authRxnCondition, 
				NOT_FOUND, thisStageRxnCondition);
		if (authRxnCondition == NOT_FOUND)
			debugPrint(SELF + "The author has chosen no reaction condition; "
					+ "returning true.");
		else debugPrint(SELF + "The current stage's reaction condition ",
				thisStageRxnCondition,
				(isTheStep ? " equals the author's reaction condition"
					: " doesn't equal the author's reaction condition "
						+ authRxnCondition),
				"; returning ", isTheStep, ".");
		if (isTheStep && recurse) throwSynthError(IS_RXN);
		return isTheStep;
	} // oneStepIs(Synthesis, int, boolean)

	//----------------------------------------------------------------------
	//					substituteRGroups
	//----------------------------------------------------------------------
	/** Replaces generic numbered R groups in molecules of this stage and
	 * previous stages with instantiated R groups. 
	 * @param	rgMols	the R groups to be substituted
	 */
	void substituteRGroups(Molecule... rgMols) {
		for (final SynthStage prevStage : prevStages) {
			prevStage.substituteRGroups(rgMols);
		} // for each previous stage
		for (final Molecule mol : molecules) {
			SubstnUtils.substituteRGroups(mol, rgMols);
		} // for each molecule
		normalizedMols = null;
		enumStereos.clear();
	} // substituteRGroups(Molecule...)

	//----------------------------------------------------------------------
	//			stdizeCalcdProds, stdizeCalcdProd
	//----------------------------------------------------------------------
	/** Convert any pentavalent N atoms in the molecules of this array to 
	 * their ylide form and toilet bowl aromatic bonds into alternating double
	 * bonds.  Modifies the original molecules in the array!
	 * @param	mols	array of molecules
	 */
	private void stdizeCalcdProds(Molecule... mols) {
		for (final Molecule mol : mols) stdizeCalcdProd(mol);
	} // stdizeCalcdProds(Molecule[])

	/** Convert any pentavalent N atoms to their ylide form and toilet bowl
	 * aromatic bonds into alternating double bonds.  Modifies the original 
	 * molecule!
	 * @param	mol	a molecule
	 */
	private void stdizeCalcdProd(Molecule mol) {
		final String SELF = "SynthStage.stdizeCalcdProd: ";
		if (parentSynth.calcdProdsStdizer == null) parentSynth.initStandardizer();
		/* try { */
			parentSynth.calcdProdsStdizer.standardize(mol);
		/* obsolete since Standardizer moved to package chemaxon.standardizer
		} catch (SearchException e) {
			Utils.alwaysPrint(SELF + "SearchException while standardizing", mol);
			e.printStackTrace();
		}
		*/
	} // stdizeCalcdProd(Molecule)

	//----------------------------------------------------------------------
	//					isEqualTo
	//----------------------------------------------------------------------
	/** Determines whether two synthetic stages are exactly equal by comparing 
	 * the contents and maybe the reaction conditions and the same features of
	 * preceding stages.  Called recursively!
	 * @param	other	the stage to be compared to this one
	 * @param	considerRxnConds	whether to consider reaction conditions in
	 * determining whether two syntheses are equal
	 * @return	true if the stages and their preceding stages are exactly equal
	 */
	boolean isEqualTo(SynthStage other, boolean considerRxnConds) {
		final String SELF = "SynthStage.isEqualTo: ";
		final int myBoxNum = getBoxIndex() + 1;
		debugPrint(SELF + "comparing stage:");
		print();
		debugPrint("to stage:");
		other.print();
		if (considerRxnConds) {
			int myRxnCondition = getRxnCondition();
			int itsRxnCondition = other.getRxnCondition();
			if (myRxnCondition == NOT_FOUND)
				myRxnCondition = NO_REAGENTS;
			if (itsRxnCondition == NOT_FOUND)
				itsRxnCondition = NO_REAGENTS;
			final String name = 
					RxnCondition.getRxnCondition(myRxnCondition).name; 
			if (myRxnCondition != itsRxnCondition) {
				final String itsName = 
						RxnCondition.getRxnCondition(itsRxnCondition).name; 
				debugPrint(SELF + "stage with box #", myBoxNum,
						" has selected reaction, ", name, ", that is not "
						+ "same as other stage's, ", itsName, ".");
				return false;
			} // if the selected reactions are different
			debugPrint(SELF + "stage with box #", myBoxNum, 
					" has selected reaction, ", name, 
					", that is identical in two syntheses.");
		} // if should consider reaction conditions
		final boolean iHavePrevStages = hasPrevStage();
		final boolean itHasPrevStages = other.hasPrevStage();
		if (iHavePrevStages != itHasPrevStages) {
			debugPrint(SELF + "stage with box #", myBoxNum, " has ", 
					iHavePrevStages ? "" : "no ", 
					"previous stages, and the other stage does", 
					itHasPrevStages ? "" : " not", ".");
			return false;
		} // if one has previous stages, the other not
		final Molecule[] myMolArray = getNormalizedMols();
		final Molecule[] itsMolArray = other.getNormalizedMols();
		final int itsBoxNum = other.getBoxIndex() + 1;
		try {
			if (!SynthSet.identical(myMolArray, itsMolArray)) {
				debugPrint(SELF + "stage with box #", myBoxNum,
						" has normalized contents, ", myMolArray, 
						", that are not same as other "
						+ "synthesis' stage with box #", itsBoxNum, 
						", which has contents ", itsMolArray, ".");
				return false;
			} // if molecules in two stages are not identical
			debugPrint(SELF + "stage with box #", myBoxNum,
					" has normalized contents, ", myMolArray, 
					", that are identical in other synthesis' stage "
					+ "with box #", itsBoxNum, ".");
		} catch (SearchException e) {
			Utils.alwaysPrint(SELF + "Caught SearchException; continuing.");
		} // try
		if (iHavePrevStages) {
			final List<SynthStage> itsPrevStages = other.getAllPrevStages();
			final int myNumPrevStages = prevStages.size();
			final int itsNumPrevStages = itsPrevStages.size();
			if (myNumPrevStages != itsNumPrevStages) {
				debugPrint(SELF + "stage with box #", myBoxNum, " has ", 
						myNumPrevStages, "previous stages, and the "
						+ "other stage has ", itsNumPrevStages, ".");
				return false;
			} // if numbers of previous stages are different
			for (int stgNum = 0; stgNum < myNumPrevStages; stgNum++) {
				final SynthStage myPrevStage = prevStages.get(stgNum);
				boolean foundMatch = false;
				for (int itsStgNum = 0; itsStgNum < myNumPrevStages; itsStgNum++) {
					foundMatch = myPrevStage.isEqualTo(itsPrevStages.get(itsStgNum),
							considerRxnConds);
					if (foundMatch) break;
				} // for each stage
				if (!foundMatch) {
					debugPrint(SELF + "stage with box #", myBoxNum,
							" has previous stage ", stgNum + 1, " with box #", 
							myPrevStage.getBoxIndex() + 1, " that cannot be "
							+ "matched to any of the previous stages of other "
							+ "stage with box #", itsBoxNum, ".");
					return false;
				} // if no previous stages match
			} // for each stage
		} // if there are previous stages
		debugPrint(SELF + "stage with box #", myBoxNum, " equals other "
				+ "stage with box #", itsBoxNum, " in all respects.");
		return true;
	} // isEqualTo(SynthStage, boolean)

	//----------------------------------------------------------------------
	//							print
	//----------------------------------------------------------------------
	/** Prints a description of the stage. */
	public void print() {
		debugPrint("Stage with box index ", getBoxIndex() + 1,
				" has reaction condition number ", getRxnCondition(),
				" and molecules ", getNormalizedMols());
	} // print()

	//----------------------------------------------------------------------
	//							throwSynthError
	//----------------------------------------------------------------------
	/** An error in the current stage warrants ACE throwing a SynthError.
	 * @param	kindOfError	represents the kind of error that the student made
	 * @throws	SynthError	always
	 */
	private void throwSynthError(int kindOfError) throws SynthError {
		throwSynthError(boxIndex, kindOfError, NO_CALC_PRODS);
	} // throwSynthError(int)

	/** An error in a stage warrants ACE throwing a SynthError.
	 * @param	boxIndex	index in the MDocument of the box of the stage that
	 * contains the error
	 * @param	kindOfError	represents the kind of error that the student made
	 * @throws	SynthError	always
	 */
	private void throwSynthError(int boxIndex, int kindOfError) throws SynthError {
		throwSynthError(boxIndex, kindOfError, NO_CALC_PRODS);
	} // throwSynthError(int, int)

	/** An error in the current stage warrants ACE throwing a SynthError.
	 * @param	kindOfError	represents the kind of error that the student made
	 * @param	calcdProds	the products calculated from this stage's reaction
	 * @throws	SynthError	always
	 */
	private void throwSynthError(int kindOfError, String calcdProds) 
			throws SynthError {
		throwSynthError(boxIndex, kindOfError, calcdProds);
	} // throwSynthError(int, String)

	/** An error in a stage warrants ACE throwing a SynthError.
	 * @param	boxIndex	index in the MDocument of the box of the stage that
	 * contains the error
	 * @param	kindOfError	represents the kind of error that the student made
	 * @param	calcdProds	the products calculated from the stage's reaction
	 * @throws	SynthError	always
	 */
	private void throwSynthError(int boxIndex, int kindOfError, 
			String calcdProds) throws SynthError {
		final String SELF = "SynthStage.throwSynthError: ";
		debugPrint(SELF + "stage with box #", boxIndex + 1, 
				", kindOfError = ", kindOfError, 
				calcdProds != null ? ", calcdProds = " + calcdProds : "");
		SynthError anError;
		if (parentSynth != null && parentSynth.parsedSynth != null) {
			try {
				final MDocument newMDoc = parentSynth.parsedSynth.getMDocCopy();
				if (boxIndex != NOT_FOUND) {
					final MRectangle box = 
							(MRectangle) newMDoc.getObject(boxIndex);
					box.setColor(Color.RED);
					box.setLineColor(Color.RED);
				} // if there's a box
				// final String rxnConds = parentSynth.getRxnConditions();
				final String newResp = MolString.toString(newMDoc, MRV)
						; // + (rxnConds != null ? rxnConds : "");
				debugPrint(SELF + "newResp =\n", newResp);
				anError = new SynthError(newResp, kindOfError, calcdProds);
			} catch (MolExportException e) {
				Utils.alwaysPrint(SELF + "MolExportException; "
						+ "cannot export modified document");
				anError = new SynthError(parentSynth.parsedSynth.getResponse(), 
						kindOfError);
			} // try
		} else {
			anError = new SynthError(kindOfError, calcdProds);
		} // if there's an MDocument to modify
		throw anError;
	} // throwSynthError(int, int, String)

} // SynthStage
