package com.epoch.evals.impl.chemEvals;

import chemaxon.struc.Molecule;
import com.epoch.chem.MolCompareException;
import com.epoch.chem.MolString;
import com.epoch.chem.StereoFunctions;
import com.epoch.constants.FormatConstants;
import com.epoch.evals.EvalInterface;
import com.epoch.evals.OneEvalResult;
import com.epoch.exceptions.ParameterException;
import com.epoch.responses.Response;
import com.epoch.utils.Utils;

/** If {none, any, some but not all, all} of the enumerated stereoisomers of the
 * response molecule(s) are {chiral, achiral} ...
 * Enumerated stereoisomers are all of the stereoisomers of a compound that
 * can be generated by specifying the configurations of stereocenters whose
 * configurations are not already specified. */
public class Chiral implements EvalInterface, FormatConstants {

	private static void debugPrint(Object... msg) {
		// Utils.printToLog(msg);
	}

	/** Proportion of compounds that have the indicated chirality characteristic. */
	private int proportion;
		/** Value for proportion.  */
		public static final int NONE = 1;
		/** Value for proportion.  */
		public static final int ANY = 2;
		/** Value for proportion.  */
		public static final int SOME_NOT_ALL = 3;
		/** Value for proportion.  */
		public static final int ALL = 4;
		/** Database values corresponding to values for proportion. */
		transient private final String[] PROPORTION_VALS =
				new String[] {"", "none", "any", "some", "all"};

	/** Whether we are looking at chirality or achirality. */
	private int kind;
		/** Value for kind.  */
		public static final int CHIRAL = 1;
		/** Value for kind.  */
		public static final int ACHIRAL = 2;
		/** Database values corresponding to values for kind. */
		transient private final String[] KIND_VALS =
				new String[] {"", "chiral", "achiral"};

	/** Constructor. */
	public Chiral() {
		proportion = ALL;
		kind = CHIRAL;
	} // Chiral()

	/** Constructor.
	 * @param	data	the coded data for this evaluator; format:<br>
	 * <code>proportion</code>/<code>kind</code>
	 * @throws	ParameterException	if the coded data is inappropriate for this
	 * evaluator
	 */
	public Chiral(String data) throws ParameterException {
		final String[] splitData = data.split("/");
		if (splitData.length >= 2) {
			proportion = Utils.indexOf(PROPORTION_VALS, splitData[0]);
			kind = Utils.indexOf(KIND_VALS, splitData[1]);
		}
		if (proportion == -1 || kind == -1 || splitData.length < 2) {
			throw new ParameterException("Chiral ERROR: unknown input data "
					+ "'" + data + "'. ");
		} // if there are not at least two tokens
	} // Chiral(String)

	/** Gets a string representation of data that this
	 * evaluator uses to evaluate a response.  Format is:<br>
	 * <code>proportion</code>/<code>kind</code>
	 * @return	the coded data
	 */
	public String getCodedData() {
		return Utils.toString(PROPORTION_VALS[proportion],
				'/', KIND_VALS[kind]);
	} // getCodedData()

	/** Gets an English-language description of this evaluator.
	 * @param	qDataTexts	the text of question data of this question, if any;
	 * not used, but required by interface
	 * @param	forPermissibleSM	whether to word the English to describe a
	 * permissible starting material in a multistep synthesis question
	 * @return	short string describing this evaluator in English
	 */
	public String toEnglish(String[] qDataTexts, boolean forPermissibleSM) {
		return toEnglish();
	} // toEnglish(String[], boolean)

	/** Gets an English-language description of this evaluator.
	 * @return	short string describing this evaluator in English
	 */
	public String toEnglish() {
		return Utils.toString("If ", proportion == SOME_NOT_ALL
					? "some but not all" : PROPORTION_VALS[proportion],
				" of the enumerated stereoisomers of the response are ",
				KIND_VALS[kind]);
	} // toEnglish()

	/** Determines whether the indicated proportion of the enumerated stereoisomers
	 * of the response have the indicated chirality.
	 * @param	response	a parsed response
	 * @param	authString	null (required by interface)
	 * @return	a OneEvalResult containing a boolean that is true if the
	 * evaluator has been satisfied.  May also contain a message describing
	 * an inability to evaluate the response because it was malformed.
	 */
	public OneEvalResult isResponseMatching(Response response,
			String authString) {
		final String SELF = "Chiral.isResponseMatching: ";
		final OneEvalResult evalResult = new OneEvalResult();
		int chiral = 0;
		int achiral = 0;
		final Molecule respMol = response.moleculeObj.clone();
		final Molecule[] respFrags = respMol.convertToFrags();
		final Molecule[] enumerated = StereoFunctions.enumerateStereo(respFrags);
		debugPrint(SELF + "respFrags = ", respFrags, 
				", enumerated stereoisomers = ", enumerated);
		final boolean areChiral = kind == CHIRAL;
		int isoNum = 0;
		for (final Molecule isomer : enumerated) {
			isoNum++;
			try {
				if (StereoFunctions.isChiral(isomer)) chiral++;
				else achiral++;
			} catch (MolCompareException e) {
				System.out.println(SELF + "MolCompareException for "
						+ MolString.toString(isomer, MRV));
				e.printStackTrace();
			} // try
			boolean done = false;
			switch (proportion) {
				case NONE:			
				case ANY:			done = (areChiral ? chiral : achiral) > 0; break;
				case SOME_NOT_ALL:	done = (chiral > 0 && achiral > 0); break;
				case ALL:			done = (areChiral ? achiral : chiral) > 0; break;
				default: System.out.println("Chiral: bad proportion"); break;
			} // switch (proportion)
			if (done && isoNum < enumerated.length - 1) {
				debugPrint(SELF + "able to get result after ",
						isoNum, " out of ", enumerated.length,
						" enumerated stereoisomers.");
				break;
			} // if can stop now
		} // for each enumerated stereoisomer
		boolean res = false;
		switch (proportion) {
			case NONE:			res = (areChiral ? chiral : achiral) == 0; break;
			case ANY:			res = (areChiral ? chiral : achiral) > 0; break;
			case SOME_NOT_ALL:	res = (chiral > 0 && achiral > 0); break;
			case ALL:			res = (areChiral ? achiral : chiral) == 0; break;
			default: System.out.println("Chiral: bad proportion"); break;
		}
		debugPrint(SELF + "proportion = ", PROPORTION_VALS[proportion],
				", kind = ", KIND_VALS[kind], ", chiral = ", chiral, 
				", achiral = ", achiral, ", result = ", res);
		evalResult.isSatisfied = res;	
		return evalResult;
	} // isResponseMatching(Response, String)

	/* *************** Get-set methods *****************/

	/** Gets the code for identifying this evaluator's type in the database.
	 * @return	short string describing the type of this evaluator
	 */
	public String getMatchCode() 			{ return EVAL_CODES[CHIRAL]; } 
	/** Gets what proportion of compounds must have the characteristic.
	 * @return	what proportion of compounds must have the characteristic
	 */
	public int getProportion()				{ return proportion; }
	/** Gets whether to count chiral or achiral compounds.
	 * @return	whether to count chiral or achiral compounds
	 */
	public int getKind() 					{ return kind; }
	/** Sets the proportion of compounds that must have the characteristic.
	 * @param	p	the proportion of compounds that must have the
	 * characteristic
	 */
	public void setProportion(int p) 		{ proportion = p; }
	/** Sets whether to count chiral or achiral compounds.
	 * @param	k	whether to count chiral or achiral compounds
	 */
	public void setKind(int k) 				{ kind = k; }
	/** Not used.  Required by interface.
	 * @param	molName	name of the molecule
	 */
	public void setMolName(String molName)	{ /* intentionally empty */ }
	/** Gets whether to calculate the grade from the response.  Required by
	 * interface.
	 * @return	true if should calculate the grade from the response
	 */
	public boolean getCalcGrade() 			{ return false; }

} // Chiral
