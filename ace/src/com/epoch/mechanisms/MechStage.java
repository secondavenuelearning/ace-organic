package com.epoch.mechanisms;

import chemaxon.struc.MDocument;
import chemaxon.struc.Molecule;
import chemaxon.struc.MolAtom;
import chemaxon.struc.graphics.MRectangle;
import chemaxon.formats.MolFormatException;
import chemaxon.marvin.io.MolExportException;
import com.epoch.chem.MolString;
import com.epoch.chem.Normalize;
import com.epoch.mechanisms.mechConstants.MechConstants;
import com.epoch.substns.SubstnUtils;
import com.epoch.utils.Utils;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/** Contains data and references to items inside a rectangle (box, stage). */
public class MechStage implements MechConstants {

	private static void debugPrint(Object... msg) { 
		// Utils.printToLog(msg);
	}

	private static void debugPrintMRV(Object... msg) {
		// Utils.printToLog(msg, MRV);
	}

	//----------------------------------------------------------------------
	//							members
	//----------------------------------------------------------------------
	/** List of electron-flow arrows in this stage of the mechanism. */
	private final List<MechFlow> flows			= new ArrayList<MechFlow>();
	/** List of molecules in this stage of the mechanism; may be clones of
	 * originals. */
	transient private final List<Molecule> molecules		= new ArrayList<Molecule>();
	/** List of molecules in this stage of the mechanism, normalized.  
	 * Populated on the fly only if needed. */
	transient private final List<Molecule> normalizedMols = new ArrayList<Molecule>();
	/** Whether the list of normalized molecules has been populated. */
	transient private boolean molsNormalized				= false;
	/** Molecule containing all original atoms of original molecules. */
	transient private Molecule fusedMol					= null;
	/** MDocument of this stage containing all graphical objects. */
	private MDocument stageMDoc					= null;
	/** Map of original atoms of stage, keyed by their original atom indices. */
	transient private Map<Integer, MolAtom> origAtomsByOrigIndices = null;
	/** Classification of each molecule in this stage as starting material,
	 * intermediate, or product as defined by student's electron-flow arrows. */
	transient private int[] moleculesClassified			= null;
	/** The box containing this stage. */
	transient private MRectangle box						= null;  
	/** The index of the box containing this stage in the MDocument. */
	transient private int boxIndex						= NOT_FOUND; 
	/** The straight arrow pointing from the previous stage in the mechanism to
	 * this one. */
	private MechArrow arrowFromPrev1			= null;
	/** The straight arrow pointing from the second of this stage's previous stages 
	 * in the mechanism to this one (exists if the mechanism has a cyclic part and 
	 * this stage is the first stage in the cyclic part). */
	private MechArrow arrowFromPrev2			= null;
	/** The straight arrow pointing from this stage to the next stage in the 
	 * mechanism. */
	private MechArrow arrowToNext				= null;
	/** The products calculated from this stage's molecules and electron-flow arrows.
	 * Populated when Mechanism.checkFlowsValid() or 
	 * Mechanism.classifyMolecules() need the values. */
	transient private Molecule[] calculatedProds			= null; 
	/** The kind of error (or lack thereof) generated by this stage's molecules 
	 * and electron-flow arrows. */
	transient private int flowArrowsStatus				= UNCHECKED;
	/** English description of the kind of error (or lack thereof) 
	 * generated by this stage's molecules and electron-flow arrows.  */
	transient private String flowArrowsStatusStr			= null;
	/** String representation (probably SMILES) of this stage's calculated products. 
	 * Used only when arrows lead to a MechError. */
	transient private String flowArrowsProds				= null; 
	/** Object indices in parent MDocument of the electron-flow arrows that
	 * cause an error.  Used only when arrows lead to a MechError. */
	transient private int[] offendingObjIndices			= new int[0]; 
	/** List of reaction or resonance arrows connecting this stage to others.
	 * Contains no directional information.  Not used after reordering of stages 
	 * in logical order.  */
	private final List<MechArrow> linkArrows	= new ArrayList<MechArrow>();
	/** If this stage has been removed from the mechanism and its contents
	 * copied into another stage, the box index of the stage into which the
	 * contents have been copied. */
	private int boxIndexOfStageCopiedInto		= 0;
	/** The index of this stage in the mechanism. */
	private int indexInMech						= NOT_FOUND;

	//----------------------------------------------------------------------
	//							constructors
	//----------------------------------------------------------------------
	/** Constructor. */
	MechStage() { /* intentionally empty */ }

	/** Constructor. 
	 * @param	newBox	the box containing this stage's molecules and 
	 * electron-flow arrows
	 * @param	newObjectIndex	the index of the box (in the MRV MDocument) 
	 */
	MechStage(MRectangle newBox, int newObjectIndex) {
		box = newBox;
		boxIndex = newObjectIndex;
	} // MechStage(MRectangle, int)

	//----------------------------------------------------------------------
	//							short add/set methods
	//----------------------------------------------------------------------
	/** Add a molecule to this stage.
	 * @param	newMol	the molecule to add
	 */
	void addMolecule(Molecule newMol)		{ molecules.add(newMol); }
	/** Add an electron-flow arrow to this stage.
	 * @param	newFlow	the electron-flow arrow to add
	 */
	void addFlow(MechFlow newFlow)			{ flows.add(newFlow); }
	/** Remove an electron-flow arrow to this stage.
	 * @param	oldFlow	the electron-flow arrow to remove 
	 */
	void removeFlow(MechFlow oldFlow)		{ flows.remove(oldFlow); }
	/** Set the straight arrow pointing from the previous stage in the mechanism to
	 * this one. 
	 * @param	arrow	the straight (reaction or resonance) arrow to set
	 */
	void setArrowFromPrev1(MechArrow arrow)	{ arrowFromPrev1 = arrow; }
	/** Set the straight arrow pointing from the second of this stage's previous stages 
	 * in the mechanism to this one (exists if the mechanism has a cyclic part and 
	 * this stage is the first stage in the cyclic part). 
	 * @param	arrow	the straight (reaction or resonance) arrow to set
	 */
	void setArrowFromPrev2(MechArrow arrow)	{ arrowFromPrev2 = arrow; }
	/** Set the straight arrow pointing from this stage to the next stage in the 
	 * mechanism. 
	 * @param	arrow	the straight (reaction or resonance) arrow to set
	 */
	void setArrowToNext(MechArrow arrow)	{ arrowToNext = arrow; }
	/** Add a reaction/resonance arrow to the list of reaction or resonance arrows 
	 * linking this stage to others.
	 * @param	arrow	the linking arrow
	 */
	void addLink(MechArrow arrow)			{ linkArrows.add(arrow); } 
	/** Set the box index of the stage into which the contents of this stage
	 * have been copied.
	 * @param	i	the box index of the stage into which the contents of this
	 * stage have been copied
	 */
	void setBoxIndexOfStageCopiedInto(int i) { boxIndexOfStageCopiedInto = i; }
	/** Sets the 0-based index of this stage in the mechanism.
	 * @param	i	the 0-based index of this stage in the mechanism
	 */
	void setIndexInMech(int i)				{ indexInMech = i; }
	
	//--------------------------------------------------------------------------
	//							short get methods
	//--------------------------------------------------------------------------
	/** Get the rectangle enclosing the molecules and electron-flow arrows of
	 * this stage.
	 * @return	this stage's rectangle
	 */
	MRectangle getBox()					{ return box; }
	/** Get an electron-flow arrow from this stage.
	 * @param	index	0-based index of the electron-flow arrow
	 * @return	the electron-flow arrow
	 */
	MechFlow getFlow(int index)			{ return flows.get(index); }
	/** Get all electron-flow arrows in this stage.
	 * @return	list of the electron-flow arrows
	 */
	List<MechFlow> getFlows()			{ return flows; }
	/** Get a molecule from this stage.
	 * @param	index	0-based index of the molecule
	 * @return	the molecule
	 */
	Molecule getMolecule(int index)		{ return molecules.get(index); }
	/** Get a normalized molecule from this stage.
	 * @param	index	0-based index of the normalized molecule
	 * @return	the normalized molecule
	 */
	Molecule getNormalizedMol(int index)	{ return normalizedMols.get(index); }
	/** Get the straight arrow pointing from the previous stage in the mechanism to
	 * this one. 
	 * @return	the straight (reaction or resonance) arrow from the previous
	 * stage; null if this stage is the first one
	 */
	MechArrow getArrowFromPrev1()		{ return arrowFromPrev1; }
	/** Get the straight arrow pointing from the second of this stage's previous stages 
	 * in the mechanism to this one (exists if the mechanism has a cyclic part and 
	 * this stage is the first stage in the cyclic part). 
	 * @return	the straight (reaction or resonance) arrow from the second of
	 * the previous stages; null if there is no second previous stage
	 */
	MechArrow getArrowFromPrev2()		{ return arrowFromPrev2; }
	/** Get the straight arrow pointing from this stage to the next stage in the 
	 * mechanism. 
	 * @return	the straight (reaction or resonance) arrow to the next stage;
	 * null if this stage is the last one
	 */
	MechArrow getArrowToNext()			{ return arrowToNext; }
	/** Get the 0-based index in the response's MDocument of the box enclosing 
	 * this stage.
	 * @return	the 0-based index of this stage's box
	 */
	int getBoxIndex()					{ return boxIndex; }
	/** Get the number of electron-flow arrows in this stage.
	 * @return	the number of electron-flow arrows in this stage
	 */
	int getNumFlows()					{ return flows.size(); }	
	/** Get the number of molecules in this stage.
	 * @return	the number of molecules in this stage
	 */
	int getNumMolecules()				{ return molecules.size(); }	
	/** Get the products calculated from this stage's molecules and electron-flow 
	 * arrows.
	 * @return	an array of molecules that are the calculated products of this
	 * stage
	 */
	Molecule[] getFlowProducts()		{ return calculatedProds; }
	/** Gets the kind of error (or lack thereof) generated by this stage's molecules 
	 * and electron-flow arrows. 
	 * @return	number representing the kind of error or lack thereof
	 */
	int getFlowArrowsStatus()			{ return flowArrowsStatus; }
	/** Gets an English description of the kind of error (or lack thereof) 
	 * generated by this stage's molecules and electron-flow arrows. 
	 * @return	description of the kind of error or lack thereof
	 */
	String getFlowArrowsStatusStr()		{ return flowArrowsStatusStr; }
	/** Get the products calculated from this stage's molecules and electron-flow 
	 * arrows.
	 * @return	String (probably SMILES) representation of this stage's calculated 
	 * products 
	 */
	String getFlowArrowsProds()			{ return flowArrowsProds; }
	/** Get the object indices of the offending electron-flow arrows.
	 * @return	object indices (in the parent MDocument) of the offending
	 * electron-flow arrows
	 */
	int[] getOffendingFlowArrows()		{ return offendingObjIndices; }
	/** Get all arrows connecting this stage to others (in no particular order).
	 * @return	list of the linking arrows
	 */
	List<MechArrow> getLinkArrows()		{ return linkArrows; }
	/** Get number of arrows connecting this stage to others.
	 * @return	number of linking arrows
	 */
	int getNumLinkArrows()				{ return linkArrows.size(); }
	/** Get the box index of the stage into which the contents of this stage
	 * have been copied.
	 * @return	the box index of the stage into which the contents of this
	 * stage have been copied
	 */
	int getBoxIndexOfStageCopiedInto()	{ return boxIndexOfStageCopiedInto; }
	/** Gets the 0-based index of this stage in the mechanism.
	 * @return	the 0-based index of this stage in the mechanism
	 */
	int getIndexInMech()				{ return indexInMech; }

	/** Gets the 0-based indices of the electron-flow arrows that point to 
	 * incipient bonds.
	 * @return	0-based indices of the electron-flow arrows that point to
	 * incipient bonds
	 */
	int[] getFlowsToIncipientBondsIndices() {
		final List<Integer> flowIndices = new ArrayList<Integer>();
		for (final MechFlow flow : flows) {
			if (flow.sinkIsIncipBond()) {
				flowIndices.add(Integer.valueOf(flow.getObjectIndex()));
			} // if the flow arrow points to an incipient bond
		} // for each flow arrow in this stage
		return Utils.listToIntArray(flowIndices);
	} // getFlowsToIncipientBondsIndices()

	//----------------------------------------------------------------------
	//				getNormalizedMolArray, getMoleculeArray 
	//----------------------------------------------------------------------
	/** Gets this stage's molecules in normalized form.  Normalizes them first
	 * if they haven't already been normalized. 
	 * @return	array of normalized molecules of this stage
	 */
	public Molecule[] getNormalizedMolArray() {
		final String SELF = "MechStage.getNormalizedMolArray: ";
		if (!molsNormalized) {
			debugPrint(SELF + "normalizing each "
					+ "molecule in this stage for the first time.");
			for (final Molecule mol : getMoleculeArray()) {
				final Molecule normMol = Normalize.mechNormalize(mol);
				debugPrintMRV(SELF + "normalized mol:\n", normMol);
				normalizedMols.add(normMol);
			} // for each molecule
			molsNormalized = true;
		} // if mols haven't been normalized yet
		return Utils.molListToArray(normalizedMols);
	} // getNormalizedMolArray()
	
	/** Get all molecules in this stage.
	 * @return	array of molecules
	 */
	public Molecule[] getMoleculeArray() { 
		return Utils.molListToArray(molecules); 
	} // getMoleculeArray()

	//----------------------------------------------------------------------
	//				 hasResonanceArrow, hasOnlyResonanceArrows 
	//----------------------------------------------------------------------
	/** Gets whether any of the linking arrows of this stage are resonance
	 * arrows.
	 * @return	true if one of the linking arrows is a resonance arrow
	 */
	boolean hasResonanceArrow() {
		for (final MechArrow arrow : linkArrows) {
			if (arrow.isResonant()) return true;
		} // for each arrow
		return false;
	} // hasResonanceArrow()

	/** Gets whether all of the linking arrows of this stage are resonance
	 * arrows.
	 * @return	true if all of the linking arrows are resonance arrows
	 */
	boolean hasOnlyResonanceArrows() {
		for (final MechArrow arrow : linkArrows) {
			if (!arrow.isResonant()) return false;
		} // for each arrow
		return true;
	} // hasOnlyResonanceArrows()

	//--------------------------------------------------------------------------
	//				getFusedMolecule, setFusedMolecule
	//--------------------------------------------------------------------------
	/** Gets the single Molecule object obtained by fusing together the 
	 * compounds of this stage.  
	 * @return	a Molecule containing all of this stage's compounds
	 */
	Molecule getFusedMolecule() {
		if (fusedMol == null) setFusedMolecule();
		return fusedMol;
	} // getFusedMolecule()

	/** Fuses together the original molecules of this stage and substitutes
	 * clones for them in the list of individual molecules.
	 */
	private void setFusedMolecule() {
		final String SELF = "MechStage.setFusedMolecule: ";
		debugPrintMRV(SELF + "stage compounds before fusing:\n", molecules);
		fusedMol = new Molecule();
		debugPrint(SELF + "fusing original molecules so that references "
				+ "to atoms in electron-flow arrows will remain "
				+ "consistent; replacing originals with clones.");
		int molNum = 0;
		for (final Molecule mol : molecules) {
			molecules.set(molNum++, mol.clone());
			fusedMol.fuse(mol);
		} // for each molecule
		debugPrintMRV(SELF + "fused molecule:\n", fusedMol);
	} // setFusedMolecule()

	//--------------------------------------------------------------------------
	//							getOrigAtomByIndex
	//--------------------------------------------------------------------------
	/** Gets the original atom of this stage by its original index.
	 * @param	origIndex	the atom's original index
	 * @return	the original MolAtom
	 */
	MolAtom getOrigAtomByIndex(Integer origIndex) {
		if (origAtomsByOrigIndices == null) {
			if (fusedMol == null) setFusedMolecule();
			origAtomsByOrigIndices = new HashMap<Integer, MolAtom>();
			for (final MolAtom atom : fusedMol.getAtomArray()) {
				final Integer atomOrigIndexObj =
						(Integer) atom.getProperty(ORIG_INDEX);
				origAtomsByOrigIndices.put(atomOrigIndexObj, atom);
			} // for each atom in fused molecule
		} // if map hasn't been initialized yet
		return origAtomsByOrigIndices.get(origIndex);
	} // getOrigAtomByIndex(Integer)

	//----------------------------------------------------------------------
	//				 		getStageMDoc, setStageMDoc
	//----------------------------------------------------------------------
	/** Gets the MDocument containing this stage's molecules and electron-flow 
	 * arrows.
	 * @return	an MDocument of this stage
	 */
	MDocument getStageMDoc() {
		if (stageMDoc == null) setStageMDoc();
		return stageMDoc;
	} // getStageMDoc()

	/** Sets the MDocument containing this stage's molecules and electron-flow 
	 * arrows.
	 */
	private void setStageMDoc() {
		final String SELF = "MechStage.setStageMDoc: ";
		if (fusedMol == null) setFusedMolecule();
		debugPrintMRV(SELF + "creating MDocument with molecule:\n", fusedMol);
		stageMDoc = new MDocument(fusedMol);
		for (final MechFlow flow : flows) {
			debugPrint(SELF + "adding flow: ");
			flow.print();
			stageMDoc.addObject(flow.getMEFlow());
		} // for each flow arrow
		debugPrint(SELF + "MRV of stage MDoc:\n", getStageXML());
	} // setStageMDoc()

	//----------------------------------------------------------------------
	//				 			getStageXML
	//----------------------------------------------------------------------
	/** Gets an MRV representation containing this stage's molecules and 
	 * electron-flow arrows, or just the fused molecules if export to MRV fails.
	 * @return	an MRV representation of this stage
	 */
	String getStageXML() {
		final String SELF = "MechStage.getStageXML: ";
		if (stageMDoc == null) setStageMDoc();
		try {
			return MolString.toString(stageMDoc, MRV);
		} catch (MolExportException e) {
			Utils.alwaysPrint(SELF + "can't export stage MDocument to XML:\n", 
					e.getMessage());
			e.printStackTrace();
		} // try
		return MolString.toString(fusedMol, MRV);
	} // getStageXML()

	//----------------------------------------------------------------------
	//						calculateFlowProducts 
	//----------------------------------------------------------------------
	/** Calculates and stores products of this stage's molecules and 
	 * electron-flow arrows.  Catches MechErrors and sets flowArrowsStatus,
	 * flowArrowsStatusStr, and flowArrowsProds accordingly.
	 * <br>NOTE: We export the MechStage contents to an MDocument, then reimport
	 * it in MechSolver, so that we don't have to modify this stage's molecule or
	 * flow arrows, which could create inconsistencies for other calculations.
	 */
	void calculateFlowProducts() { 
		final String SELF = "MechStage.calculateFlowProducts: ";
		if (getNumFlows() == 0) {
			debugPrint(SELF + "this stage has no electron-flow arrows; "
					+ "no need to go to MechSolver.");
			flowArrowsStatus = NO_FLOW_ARROWS;
			flowArrowsStatusStr = "Stage has no electron-flow arrows.";
			calculatedProds = new Molecule[0];
		} else try {
			debugPrint(SELF + "submitting to MechSolver ...");
			final MechSolver solver = new MechSolver(getStageXML());
			final Molecule products = solver.getProducts();
			debugPrint(SELF + "back from MechSolver; got products: ", 
					products);
			debugPrintMRV(products);
			flowArrowsStatus = ARROWS_OK;
			calculatedProds = products.convertToFrags();
			debugPrint(SELF + "after fragmenting: ", calculatedProds);
			debugPrintMRV(calculatedProds, "");
		} catch (MechError e) {
			flowArrowsStatus = e.errorNumber;
			flowArrowsStatusStr = e.getMessage();
			flowArrowsProds = e.calcdProds; // for display to students
			if (flowArrowsStatus == FLOWS_GIVE_NO_PRODS) {
				// highlightObjIndices contain sequence numbers of flow arrows
				// in this stage's MDocument; need to convert them to their 
				// object indices in the original response
				for (int flowNum = 0; flowNum < e.highlightObjIndices.length; 
						flowNum++) {
					e.highlightObjIndices[flowNum] = flows.get(
							e.highlightObjIndices[flowNum]).getObjectIndex();
				} // for each flow number
				debugPrint(SELF + "highlighted 0-based flow indices: ", 
						e.highlightObjIndices);
			} // if errorNumber
			offendingObjIndices = e.highlightObjIndices;
			debugPrint(SELF + "MechError: ", flowArrowsStatusStr);
		} catch (MolFormatException e) {
			Utils.alwaysPrint(SELF + "MolFormatException:\n", e.getMessage());
		} // try
	} // calculateFlowProducts()
	
	//--------------------------------------------------------------------------
	//							classifyMolecules
	//--------------------------------------------------------------------------
	/** Given the calculated e-flow products of previous stages, classify each 
	 * molecule in this stage as response product/starter/intermediate.
	 * <ul>
	 * <li>A compound in a response is considered a RESPONSE PRODUCT if none of 
	 * its atoms or bonds are sources or sinks of electron-flow arrows.
	 * <li>A compound in a response is considered a RESPONSE STARTING MATERIAL 
	 * EITHER if it is in the first box, OR
	 * if it is not a RESPONSE PRODUCT AND the compound is NOT calculated to 
	 * be produced from the electron-flow arrows of all previous stages of 
	 * the mechanism.
	 * <li>A compound in a response is considered a RESPONSE INTERMEDIATE if it 
	 * is neither a RESPONSE STARTING MATERIAL nor a RESPONSE PRODUCT.
	 * </ul>
	 * @param	prevProducts	products of previous stages in this mechanism
	 * @param	flags	sets resonance permissiveness, double-bond isomer
	 * leniency 
	 */
	void classifyMolecules(Molecule[] prevProducts, int flags) {
		final String SELF = "MechStage.classifyMolecules: ";
		final int numMols = getNumMolecules();
		if (numMols == 0 // nothing to classify
				|| moleculesClassified != null) // already classified
			return;
		moleculesClassified = new int[numMols]; // parallel to molecules
		if (arrowFromPrev1 == null) debugPrint(SELF + "no previous stage");
		else if (prevProducts == null) {
			debugPrint(SELF + "no prevProds given (MechError)");
		} else {
			int prodNum = 0;
			debugPrint(SELF);
			for (final Molecule prevProd : prevProducts) {
				debugPrint("		  prevProd ", ++prodNum, ": ", prevProd);
			} // for each prevProduct prodNum
		} // if prevProds
		getNormalizedMolArray();
		for (int molIndex = 0; molIndex < numMols; molIndex++) {
			final Molecule cpd = getNormalizedMol(molIndex);
			if (arrowFromPrev1 == null) {
				debugPrint(SELF, cpd, " in 1st box; classified as starter");
				moleculesClassified[molIndex] = RESPONSE_STARTER;
			} else if (!hasSourceOrSink(cpd)) {
				debugPrint(SELF, cpd, " not touched by eflow arrow; "
						+ "classified as product");
				moleculesClassified[molIndex] = RESPONSE_PRODUCT;
			} else if (MechSet.molInArray(cpd, prevProducts, flags) == NOT_FOUND) {
				debugPrint(SELF, cpd, " touched by eflow arrow but not among "
						+ "previous products; classified as starter");
				moleculesClassified[molIndex] = RESPONSE_STARTER;
			} else {
				debugPrint(SELF, cpd, " touched by eflow arrow and among "
						+ "previous products; classified as intermediate");
				moleculesClassified[molIndex] = RESPONSE_INTERMEDIATE;
			} // if starter, product, intermediate 
		} // for each molecule
	} // classifyMolecules()

	//--------------------------------------------------------------------------
	//							getMolStatus
	//--------------------------------------------------------------------------
	/** Gets whether a molecule is a response starter, intermediate, or product.
	 * @param	molIndex	0-based index of the molecule
	 * @return	RESPONSE_STARTER, RESPONSE_INTERMEDIATE, RESPONSE_PRODUCT, or
	 * UNKNOWN
	 */
	int getMolStatus(int molIndex) {
		return (molIndex >= 0 && molIndex < moleculesClassified.length
				? moleculesClassified[molIndex] : UNKNOWN);
	} // getMolStatus(int)

	/** Gets an English phrase describing the status of a molecule (response
	 * starter, intermediate, or product).
	 * @param	status	the status
	 * @return	starter, intermediate, or product
	 */
	static String statusToEnglish(int status) {
		return (status == RESPONSE_STARTER ? "starter"
				: status == RESPONSE_PRODUCT ? "product"
				: status ==  RESPONSE_INTERMEDIATE ? "intermediate"
				: "unknown");
	} // statusToEnglish(int)

	//--------------------------------------------------------------------------
	//						getResponseProducts
	//--------------------------------------------------------------------------
	/** Gets the compounds in this stage that have been classifed as response
	 * products by classifyMolecules().
	 * @return	an array of molecules that have been classified as response
	 * products; null if there are none
	 */
	Molecule[] getResponseProducts() {
		if (moleculesClassified == null) return null;
		final List<Molecule> products = new ArrayList<Molecule>();
		for (int molIndex = 0; molIndex < getNumMolecules(); molIndex++) {
			if (moleculesClassified[molIndex] == RESPONSE_PRODUCT) 
				products.add(getNormalizedMol(molIndex));
		} // for each molecule
		if (products.isEmpty()) return null;
		else return Utils.molListToArray(products);
	} // getResponseProducts()

	//--------------------------------------------------------------------------
	//							getResponseStarters
	//--------------------------------------------------------------------------
	/** Gets the compounds in this stage that have been classifed as response
	 * starters by classifyMolecules().
	 * @return	an array of molecules that have been classified as response
	 * starters; null if there are none
	 */
	Molecule[] getResponseStarters() {
		if (moleculesClassified == null) return null;
		final List<Molecule> starters = new ArrayList<Molecule>();
		for (int molIndex = 0; molIndex < getNumMolecules(); molIndex++) {
			if (moleculesClassified[molIndex] == RESPONSE_STARTER) 
				starters.add(getNormalizedMol(molIndex));
		} // for each molecule
		if (starters.isEmpty()) return null;
		else return Utils.molListToArray(starters);
	} // getResponseStarters()

	//--------------------------------------------------------------------------
	//							getResponseIntermediates
	//--------------------------------------------------------------------------
	/** Gets the compounds in this stage that have been classifed as response
	 * intermediates by classifyMolecules().
	 * @return	an array of molecules that have been classified as response
	 * intermediates; null if there are none
	 */
	Molecule[] getResponseIntermediates() {
		if (moleculesClassified == null) return null;
		final List<Molecule> intermediates = new ArrayList<Molecule>();
		for (int molIndex = 0; molIndex < getNumMolecules(); molIndex++) {
			if (moleculesClassified[molIndex] == RESPONSE_INTERMEDIATE) 
				intermediates.add(getNormalizedMol(molIndex));
		} // for each molecule
		if (intermediates.isEmpty()) return null;
		else return Utils.molListToArray(intermediates);
	} // getResponseIntermediates()

	//----------------------------------------------------------------------
	//							substituteRGroups
	//----------------------------------------------------------------------
	/** Replaces generic numbered R groups in molecules of this stage with 
	 * instantiated R groups. 
	 * @param	rgMols	the R groups to be substituted
	 */
	void substituteRGroups(Molecule[] rgMols) {
		for (final Molecule mol : getMoleculeArray()) {
			SubstnUtils.substituteRGroups(mol, rgMols);
		} // for each molecule
		normalizedMols.clear();
	} // substituteRGroups(Molecule[])

	//--------------------------------------------------------------------------
	//							hasSourceOrSink
	//--------------------------------------------------------------------------
	/** Gets whether an electron-flow arrow of this stage touches a compound.
	 * Need to use original atom indices stored in each atom's properties, and not 
	 * direct references to atoms, because original molecules may already have
	 * been replaced with clones.
	 * @param	compound	the compound
	 * @return	true if an electron-flow arrow of this stage touches the
	 * compound
	 */
	boolean hasSourceOrSink(Molecule compound) {
		for (final MechFlow flow : flows) {
			for (int num = 0; num < 2; num++) {
				final MolAtom[] atoms = (num == 0 
						? flow.getSrcAtoms() : flow.getSinkAtoms());
				for (int atomNum = 0; atomNum < atoms.length; atomNum++) {
					final Integer flowAtomOrigIndexObj =
							(Integer) atoms[atomNum].getProperty(ORIG_INDEX);
					for (final MolAtom cpdAtom : compound.getAtomArray()) {
						final Integer cpdAtomOrigIndexObj =
								(Integer) cpdAtom.getProperty(ORIG_INDEX);
						if (cpdAtomOrigIndexObj.equals(flowAtomOrigIndexObj)) {
							return true;
						} // if original indices match
					} // for each atom of compound
				} // for each atom of the flow
			} // once for source and once for sink
		} // for each flow
		return false;
	} // hasSourceOrSink(Molecule)

	//--------------------------------------------------------------------------
	//							getMoleculeForAtom
	//--------------------------------------------------------------------------
	/** Gets the molecule of this stage that contains an atom.
	 * @param	atom	an atom
	 * @return	the molecule of this stage that contains the atom; 
	 * null if the atom's parent is not in this stage
	 */
	Molecule getMoleculeForAtom(MolAtom atom) {
		for (final Molecule mol : getMoleculeArray()) {
			if (mol.indexOf(atom) >= 0) return mol;
		} // for each molecule
		return null;
	} // getMoleculeForAtom()

	//--------------------------------------------------------------------------
	//							getMolecularity
	//--------------------------------------------------------------------------
	/** Counts the number of molecules in this stage that are touched by
	 * electron-flow arrows.  We import an XML of the stage rather than using
	 * the stage's original molecules and MechFlows because we don't want the
	 * latter to become inconsistent.
	 * @return	the number of molecules in this stage that are touched by
	 * electron-flow arrows
	 */
	int getMolecularity() {
		final String SELF = "MechStage.getMolecularity: ";
		final List<Molecule> touchedMols = new ArrayList<Molecule>();
		for (final MechFlow flow : flows) {
			final MolAtom[] srcAtoms = flow.getSrcAtoms();
			for (int molNum = molecules.size() - 1; molNum >= 0; molNum--) {
				final Molecule mol = molecules.get(molNum); 
				if (mol.contains(srcAtoms[0])) {
					touchedMols.add(mol);
					molecules.remove(mol);
					break;
				} // if mol contains the atom
			} // for each mol
			if (molecules.isEmpty()) break;
			final MolAtom[] sinkAtoms = flow.getSinkAtoms();
			for (int molNum = molecules.size() - 1; molNum >= 0; molNum--) {
				final Molecule mol = molecules.get(molNum); 
				if (mol.contains(sinkAtoms[0])) {
					touchedMols.add(mol);
					molecules.remove(mol);
					break;
				} // if mol contains the atom
			} // for each mol
			if (molecules.isEmpty()) break;
			if (flow.sinkIsIncipBond()) {
				for (int molNum = molecules.size() - 1; molNum >= 0; molNum--) {
					final Molecule mol = molecules.get(molNum); 
					if (mol.contains(sinkAtoms[1])) {
						touchedMols.add(mol);
						molecules.remove(mol);
						break;
					} // if mol contains the atom
				} // for each mol
			} // if sink is incipient bond
			if (molecules.isEmpty()) break;
		} // for each flow
		final int numTouched = touchedMols.size();
		molecules.addAll(touchedMols); // restore list
		debugPrint(SELF + "found ", numTouched, " molecules touched by ", 
				getNumFlows(), " electron-flow arrows out of ",
				getNumMolecules(), " molecules.");
		return numTouched;
	} // getMolecularity()

	//----------------------------------------------------------------------
	//							isEqualTo
	//----------------------------------------------------------------------	
	/** Gets whether a stage is equal to this one.  Two stages are equal if they
	 * contain the same molecules and their calculated products are the same.
	 * @param	other	another stage
	 * @return	true if the stage equals this one
	 */
	boolean isEqualTo(MechStage other) {
		final String SELF = "MechStage.isEqualTo: ";
		// low-hanging fruit: count molecules, arrows, calculated products
		if (other == null) {
			debugPrint(SELF + "stages are unequal; other stage is null");
			return false;
		} else if (getNumMolecules() != other.getNumMolecules()
				|| getNumFlows() != other.getNumFlows()) {
			debugPrint(SELF + "stages are unequal; numMolecules are ",
					getNumMolecules(), " and ", other.getNumMolecules(),
					", numFlows are ", getNumFlows(), " and ", other.getNumFlows());
			return false;
		} // if they don't match
		if (flowArrowsStatus == UNCHECKED) {
			debugPrint(SELF + "calculating flow products of this stage.");
			calculateFlowProducts();
		} else {
			debugPrint(SELF + "have already calculated flow products of "
					+ "this stage.");
		} // if flowArrowsStatus
		if (other.getFlowArrowsStatus() == UNCHECKED) {
			debugPrint(SELF + "calculating flow products of stage being "
					+ "compared.");
			other.calculateFlowProducts();
		} else {
			debugPrint(SELF + "have already calculated flow products of stage "
					+ "being compared.");
		} // if other.getFlowArrowsStatus()
		if (flowArrowsStatus != other.getFlowArrowsStatus()) {
			debugPrint(SELF + "stages are unequal; flowArrowsStatuses are ",
					flowArrowsStatus, " and ", other.getFlowArrowsStatus());
			return false;
		}
		final Molecule[] myCalcProds = getFlowProducts();
		final Molecule[] itsCalcProds = other.getFlowProducts();
		if (Utils.getLength(myCalcProds) != Utils.getLength(itsCalcProds)) {
			debugPrint(SELF + "stages are unequal; numbers of calculated products "
					+ "are ", Utils.getLength(myCalcProds), " and ", 
					Utils.getLength(itsCalcProds));
			return false;
		}
		// compare lists of molecules & calculated products
		final Molecule[] myMols = getMoleculeArray();
		final Molecule[] itsMols = other.getMoleculeArray();
		debugPrintMRV(SELF + "compounds of this stage:\n", myMols);
		debugPrintMRV(SELF + "compounds of stage being compared:\n", itsMols);
		boolean listsSame = false;
		listsSame = MechSet.identical(myMols, itsMols, NOT_LENIENT); 
		if (!listsSame) {
			debugPrint(SELF + "stages are unequal; molecules are ", 
					myMols, " and ", itsMols);
		} else {
			debugPrint(SELF + "stages have same molecules:", myMols);
			listsSame = MechSet.identical(myCalcProds, itsCalcProds, NOT_LENIENT);
			if (!listsSame) {
				debugPrint(SELF + "stages are unequal; calculated "
						+ "products are ", myCalcProds, " and ", itsCalcProds);
			} else debugPrint(SELF + "stages have same calculated "
					+ "products: ", myCalcProds, 
					"; stages are equal in all respects");
		} // if stage molecules are different
		return listsSame;
	} // isEqualTo(MechStage)

} // MechStage
 
